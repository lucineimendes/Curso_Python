[
    {
        "id": "cheat-sheet",
        "course_id": "git-avancado",
        "title": "Git Cheat Sheet - Referência Rápida",
        "order": 0,
        "description": "Referência rápida de comandos Git",
        "learning_objectives": [],
        "key_concepts": [],
        "content": "<h1>Git Cheat Sheet - Referência Rápida</h1>\n<h2>Configuração</h2>\n<div class=\"codehilite\"><pre><span></span><code>git<span class=\"w\"> </span>config<span class=\"w\"> </span>--global<span class=\"w\"> </span>user.name<span class=\"w\"> </span><span class=\"s2\">&quot;Nome&quot;</span>\ngit<span class=\"w\"> </span>config<span class=\"w\"> </span>--global<span class=\"w\"> </span>user.email<span class=\"w\"> </span><span class=\"s2\">&quot;email@exemplo.com&quot;</span>\ngit<span class=\"w\"> </span>config<span class=\"w\"> </span>--list<span class=\"w\">                  </span><span class=\"c1\"># Ver config</span>\n</code></pre></div>\n\n<h2>Básico</h2>\n<div class=\"codehilite\"><pre><span></span><code>git<span class=\"w\"> </span>init<span class=\"w\">                           </span><span class=\"c1\"># Iniciar repositório</span>\ngit<span class=\"w\"> </span>clone<span class=\"w\"> </span>&lt;url&gt;<span class=\"w\">                    </span><span class=\"c1\"># Clonar repositório</span>\ngit<span class=\"w\"> </span>status<span class=\"w\">                         </span><span class=\"c1\"># Ver estado dos arquivos</span>\ngit<span class=\"w\"> </span>add<span class=\"w\"> </span>&lt;arquivo&gt;<span class=\"w\">                  </span><span class=\"c1\"># Adicionar ao stage</span>\ngit<span class=\"w\"> </span>add<span class=\"w\"> </span>.<span class=\"w\">                          </span><span class=\"c1\"># Adicionar tudo</span>\ngit<span class=\"w\"> </span>commit<span class=\"w\"> </span>-m<span class=\"w\"> </span><span class=\"s2\">&quot;Mensagem&quot;</span><span class=\"w\">           </span><span class=\"c1\"># Comitar</span>\ngit<span class=\"w\"> </span>log<span class=\"w\"> </span>--oneline<span class=\"w\">                  </span><span class=\"c1\"># Histórico resumido</span>\n</code></pre></div>\n\n<h2>Branches</h2>\n<div class=\"codehilite\"><pre><span></span><code>git<span class=\"w\"> </span>branch<span class=\"w\">                         </span><span class=\"c1\"># Listar branches</span>\ngit<span class=\"w\"> </span>branch<span class=\"w\"> </span>&lt;nome&gt;<span class=\"w\">                  </span><span class=\"c1\"># Criar branch</span>\ngit<span class=\"w\"> </span>checkout<span class=\"w\"> </span>&lt;nome&gt;<span class=\"w\">                </span><span class=\"c1\"># Mudar de branch</span>\ngit<span class=\"w\"> </span>checkout<span class=\"w\"> </span>-b<span class=\"w\"> </span>&lt;nome&gt;<span class=\"w\">             </span><span class=\"c1\"># Criar e mudar</span>\ngit<span class=\"w\"> </span>merge<span class=\"w\"> </span>&lt;nome&gt;<span class=\"w\">                   </span><span class=\"c1\"># Mesclar branch no atual</span>\ngit<span class=\"w\"> </span>branch<span class=\"w\"> </span>-d<span class=\"w\"> </span>&lt;nome&gt;<span class=\"w\">               </span><span class=\"c1\"># Deletar branch</span>\n</code></pre></div>\n\n<h2>Remoto</h2>\n<div class=\"codehilite\"><pre><span></span><code>git<span class=\"w\"> </span>remote<span class=\"w\"> </span>add<span class=\"w\"> </span>origin<span class=\"w\"> </span>&lt;url&gt;<span class=\"w\">        </span><span class=\"c1\"># Adicionar remoto</span>\ngit<span class=\"w\"> </span>push<span class=\"w\"> </span>-u<span class=\"w\"> </span>origin<span class=\"w\"> </span>&lt;branch&gt;<span class=\"w\">        </span><span class=\"c1\"># Enviar (primeira vez)</span>\ngit<span class=\"w\"> </span>push<span class=\"w\">                           </span><span class=\"c1\"># Enviar alterações</span>\ngit<span class=\"w\"> </span>pull<span class=\"w\">                           </span><span class=\"c1\"># Trazer alterações</span>\ngit<span class=\"w\"> </span>fetch<span class=\"w\">                          </span><span class=\"c1\"># Trazer sem mesclar</span>\n</code></pre></div>\n\n<h2>Avançado</h2>\n<div class=\"codehilite\"><pre><span></span><code>git<span class=\"w\"> </span>commit<span class=\"w\"> </span>--amend<span class=\"w\">                 </span><span class=\"c1\"># Corrigir último commit</span>\ngit<span class=\"w\"> </span>rebase<span class=\"w\"> </span>-i<span class=\"w\"> </span>&lt;commit&gt;<span class=\"w\">             </span><span class=\"c1\"># Rebase interativo</span>\ngit<span class=\"w\"> </span>reset<span class=\"w\"> </span>--hard<span class=\"w\"> </span>HEAD~1<span class=\"w\">            </span><span class=\"c1\"># Voltar 1 commit (destrutivo)</span>\ngit<span class=\"w\"> </span>reflog<span class=\"w\">                         </span><span class=\"c1\"># Histórico de ações (salva vidas)</span>\ngit<span class=\"w\"> </span>cherry-pick<span class=\"w\"> </span>&lt;hash&gt;<span class=\"w\">             </span><span class=\"c1\"># Copiar commit específico</span>\ngit<span class=\"w\"> </span>stash<span class=\"w\">                          </span><span class=\"c1\"># Guardar mudanças temporariamente</span>\ngit<span class=\"w\"> </span>stash<span class=\"w\"> </span>pop<span class=\"w\">                      </span><span class=\"c1\"># Recuperar mudanças</span>\ngit<span class=\"w\"> </span>bisect<span class=\"w\"> </span>start<span class=\"w\">                   </span><span class=\"c1\"># Iniciar busca de bug</span>\n</code></pre></div>",
        "examples": [],
        "summary": "",
        "estimated_time_minutes": 10
    },
    {
        "id": "01-basic-theory-basics",
        "course_id": "git-avancado",
        "title": "Módulo 01: Fundamentos do Git",
        "order": 1,
        "description": "Lição do módulo 01-basic",
        "learning_objectives": [],
        "key_concepts": [],
        "content": "<h1>Módulo 01: Fundamentos do Git</h1>\n<h2>Introdução</h2>\n<p>O Git é um sistema de controle de versão distribuído, essencial para qualquer desenvolvedor moderno. Ele permite rastrear mudanças no seu código, reverter para versões anteriores e colaborar com outros desenvolvedores.</p>\n<h2>1. Instalação e Configuração</h2>\n<p>Antes de começar, você precisa identificar-se para o Git. Isso garante que seus commits tenham sua autoria correta.</p>\n<div class=\"codehilite\"><pre><span></span><code>git<span class=\"w\"> </span>config<span class=\"w\"> </span>--global<span class=\"w\"> </span>user.name<span class=\"w\"> </span><span class=\"s2\">&quot;Seu Nome&quot;</span>\ngit<span class=\"w\"> </span>config<span class=\"w\"> </span>--global<span class=\"w\"> </span>user.email<span class=\"w\"> </span><span class=\"s2\">&quot;seu.email@exemplo.com&quot;</span>\n</code></pre></div>\n\n<p>Para verificar suas configurações:</p>\n<div class=\"codehilite\"><pre><span></span><code>git<span class=\"w\"> </span>config<span class=\"w\"> </span>--list\n</code></pre></div>\n\n<h2>2. O Ciclo de Vida Básico</h2>\n<p>O fluxo de trabalho básico no Git envolve três estados principais:\n1.  <strong>Working Directory</strong>: Onde você edita seus arquivos.\n2.  <strong>Staging Area (Index)</strong>: Onde você prepara as mudanças para serem salvas.\n3.  <strong>Repository</strong>: Onde o Git armazena permanentemente o histórico.</p>\n<h3>Comandos Essenciais</h3>\n<ul>\n<li><code>git init</code>: Inicializa um novo repositório Git no diretório atual.</li>\n<li><code>git add &lt;arquivo&gt;</code>: Move mudanças do Working Directory para a Staging Area.</li>\n<li><code>git commit -m \"mensagem\"</code>: Grava as mudanças da Staging Area no Repositório.</li>\n</ul>\n<h2>3. Visualizando o Histórico</h2>\n<p>Para ver o que aconteceu no projeto até agora, usamos o comando <code>log</code>.</p>\n<div class=\"codehilite\"><pre><span></span><code>git<span class=\"w\"> </span>log\n</code></pre></div>\n\n<p>Isso mostra o hash do commit, autor, data e mensagem. Para uma versão mais resumida:</p>\n<div class=\"codehilite\"><pre><span></span><code>git<span class=\"w\"> </span>log<span class=\"w\"> </span>--oneline\n</code></pre></div>\n\n<h2>4. Ignorando Arquivos</h2>\n<p>Nem tudo deve ser versionado (arquivos temporários, builds, senhas). Para isso, criamos um arquivo chamado <code>.gitignore</code>.</p>\n<p>Exemplo de <code>.gitignore</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c1\"># Ignorar arquivos temporários do Python</span>\n<span class=\"nf\">__pycache__</span><span class=\"err\">/</span>\n<span class=\"err\">*</span><span class=\"na\">.pyc</span>\n\n<span class=\"c1\"># Ignorar arquivos de ambiente</span>\n<span class=\"na\">.env</span>\n</code></pre></div>",
        "examples": [],
        "summary": "",
        "estimated_time_minutes": 30
    },
    {
        "id": "01-basic-lab-first-commit",
        "course_id": "git-avancado",
        "title": "Laboratório 01: Seu Primeiro Commit",
        "order": 2,
        "description": "Lição do módulo 01-basic",
        "learning_objectives": [],
        "key_concepts": [],
        "content": "<h1>Laboratório 01: Seu Primeiro Commit</h1>\n<p><strong>Objetivo</strong>: Configurar o Git, iniciar um repositório e fazer seu primeiro commit.</p>\n<h2>Passo 1: Configuração</h2>\n<p>Abra seu terminal e configure sua identidade (se ainda não o fez):</p>\n<div class=\"codehilite\"><pre><span></span><code>git<span class=\"w\"> </span>config<span class=\"w\"> </span>--global<span class=\"w\"> </span>user.name<span class=\"w\"> </span><span class=\"s2\">&quot;Aluno Git&quot;</span>\ngit<span class=\"w\"> </span>config<span class=\"w\"> </span>--global<span class=\"w\"> </span>user.email<span class=\"w\"> </span><span class=\"s2\">&quot;aluno@curso.com&quot;</span>\n</code></pre></div>\n\n<h2>Passo 2: Inicializando o Projeto</h2>\n<ol>\n<li>\n<p>Crie uma pasta para o projeto:\n    <code>bash\n    mkdir meu-projeto-git\n    cd meu-projeto-git</code></p>\n</li>\n<li>\n<p>Inicialize o Git:\n    <code>bash\n    git init</code>\n    <em>Observe que uma pasta oculta <code>.git</code> foi criada.</em></p>\n</li>\n</ol>\n<h2>Passo 3: Criando e Salvando Arquivos</h2>\n<ol>\n<li>\n<p>Crie um arquivo chamado <code>hello.txt</code>:\n    <code>bash\n    echo \"Olá, Git!\" &gt; hello.txt</code></p>\n</li>\n<li>\n<p>Verifique o status:\n    <code>bash\n    git status</code>\n    <em>O arquivo aparecerá como \"Untracked\".</em></p>\n</li>\n<li>\n<p>Adicione o arquivo à Staging Area:\n    <code>bash\n    git add hello.txt</code></p>\n</li>\n<li>\n<p>Comite o arquivo:\n    <code>bash\n    git commit -m \"Meu primeiro commit: adicionando hello.txt\"</code></p>\n</li>\n</ol>\n<h2>Passo 4: Ignorando Arquivos</h2>\n<ol>\n<li>\n<p>Crie um arquivo secreto:\n    <code>bash\n    echo \"minha-senha-secreta\" &gt; segredo.txt</code></p>\n</li>\n<li>\n<p>Crie o arquivo <code>.gitignore</code> e adicione o nome do arquivo secreto:\n    <code>bash\n    echo \"segredo.txt\" &gt; .gitignore</code></p>\n</li>\n<li>\n<p>Verifique o status novamente:\n    <code>bash\n    git status</code>\n    <em>Apenas o <code>.gitignore</code> deve aparecer como novo arquivo. O <code>segredo.txt</code> será ignorado.</em></p>\n</li>\n<li>\n<p>Comite o <code>.gitignore</code>:\n    <code>bash\n    git add .gitignore\n    git commit -m \"Configurando gitignore\"</code></p>\n</li>\n</ol>\n<h2>Passo 5: Verificando o Histórico</h2>\n<p>Veja seus dois commits:</p>\n<div class=\"codehilite\"><pre><span></span><code>git<span class=\"w\"> </span>log<span class=\"w\"> </span>--oneline\n</code></pre></div>",
        "examples": [],
        "summary": "",
        "estimated_time_minutes": 30
    },
    {
        "id": "02-intermediario-theory-branches",
        "course_id": "git-avancado",
        "title": "Módulo 02: Branches e Colaboração",
        "order": 3,
        "description": "Lição do módulo 02-intermediario",
        "learning_objectives": [],
        "key_concepts": [],
        "content": "<h1>Módulo 02: Branches e Colaboração</h1>\n<h2>Introdução</h2>\n<p>Até agora, trabalhamos em uma linha do tempo única. Porém, em projetos reais, precisamos trabalhar em múltiplas funcionalidades simultaneamente sem interferir no trabalho dos outros. É aqui que entram os <strong>Branches</strong>.</p>\n<h2>1. O que são Branches?</h2>\n<p>Um branch é simplesmente um ponteiro móvel para um commit. O branch padrão no Git é geralmente chamado de <code>master</code> ou <code>main</code>.</p>\n<h3>Comandos de Branching</h3>\n<ul>\n<li><code>git branch</code>: Lista os branches existentes.</li>\n<li><code>git branch &lt;nome&gt;</code>: Cria um novo branch.</li>\n<li><code>git checkout &lt;nome&gt;</code> ou <code>git switch &lt;nome&gt;</code>: Muda para o branch especificado.</li>\n<li><code>git checkout -b &lt;nome&gt;</code>: Cria e muda para o branch em um comando.</li>\n</ul>\n<h2>2. Mesclando Alterações (Merge)</h2>\n<p>Quando terminamos o trabalho em um branch, precisamos trazer essas mudanças de volta para o branch principal.</p>\n<div class=\"codehilite\"><pre><span></span><code>git<span class=\"w\"> </span>checkout<span class=\"w\"> </span>main\ngit<span class=\"w\"> </span>merge<span class=\"w\"> </span>feature-login\n</code></pre></div>\n\n<p>Isso integra o histórico do branch <code>feature-login</code> no <code>main</code>.</p>\n<h2>3. Resolvendo Conflitos</h2>\n<p>Se duas pessoas alterarem a mesma linha do mesmo arquivo de maneiras diferentes, o Git não saberá qual escolher. Isso gera um <strong>Conflito</strong>.\nO Git pausará o merge, marcará o arquivo conflituoso e pedirá que você resolva manualmente.</p>\n<h2>4. Repositórios Remotos</h2>\n<p>Para colaborar, usamos repositórios hospedados em servidores (GitHub, GitLab, Bitbucket).</p>\n<ul>\n<li><code>git clone &lt;url&gt;</code>: Copia um repositório remoto.</li>\n<li><code>git push origin &lt;branch&gt;</code>: Envia seus commits locais para o remoto.</li>\n<li><code>git pull</code>: Traz as atualizações do remoto para sua máquina.</li>\n</ul>",
        "examples": [],
        "summary": "",
        "estimated_time_minutes": 30
    },
    {
        "id": "02-intermediario-lab-merge-conflict",
        "course_id": "git-avancado",
        "title": "Laboratório 02: Merge e Conflitos",
        "order": 4,
        "description": "Lição do módulo 02-intermediario",
        "learning_objectives": [],
        "key_concepts": [],
        "content": "<h1>Laboratório 02: Merge e Conflitos</h1>\n<p><strong>Objetivo</strong>: Praticar a criação de branches, fazer merge e resolver um conflito intencional.</p>\n<h2>Passo 1: Preparação</h2>\n<ol>\n<li>\n<p>Crie um novo diretório e inicialize o git (ou continue do lab anterior):\n    <code>bash\n    mkdir lab-merge\n    cd lab-merge\n    git init</code></p>\n</li>\n<li>\n<p>Crie um arquivo base:\n    <code>bash\n    echo \"Conteúdo original\" &gt; arquivo.txt\n    git add arquivo.txt\n    git commit -m \"Commit inicial\"</code></p>\n</li>\n</ol>\n<h2>Passo 2: Criando um Feature Branch</h2>\n<ol>\n<li>\n<p>Crie e mude para um branch chamado <code>feature-a</code>:\n    <code>bash\n    git checkout -b feature-a</code></p>\n</li>\n<li>\n<p>Modifique o arquivo:\n    <code>bash\n    echo \"Alteração da Feature A\" &gt;&gt; arquivo.txt\n    git commit -am \"Feature A finalizada\"</code></p>\n</li>\n<li>\n<p>Volte para a main:\n    <code>bash\n    git checkout main</code>\n    <em>Observe que o conteúdo do <code>arquivo.txt</code> voltou ao original.</em></p>\n</li>\n</ol>\n<h2>Passo 3: Criando um Conflito</h2>\n<ol>\n<li>\n<p>Crie outro branch chamado <code>feature-b</code>:\n    <code>bash\n    git checkout -b feature-b</code></p>\n</li>\n<li>\n<p>Modifique <strong>a mesma linha</strong> que foi alterada na <code>feature-a</code>:\n    <code>bash\n    echo \"Alteração da Feature B (CONFLITO)\" &gt;&gt; arquivo.txt\n    git commit -am \"Feature B finalizada\"</code></p>\n</li>\n</ol>\n<h2>Passo 4: O Merge Conflituoso</h2>\n<ol>\n<li>\n<p>Volte para a main e faça merge da <code>feature-a</code> (sem conflito):\n    <code>bash\n    git checkout main\n    git merge feature-a</code></p>\n</li>\n<li>\n<p>Tente fazer merge da <code>feature-b</code>:\n    <code>bash\n    git merge feature-b</code>\n    <em>O Git deve avisar: \"CONFLICT (content): Merge conflict in arquivo.txt\".</em></p>\n</li>\n</ol>\n<h2>Passo 5: Resolvendo o Conflito</h2>\n<ol>\n<li>\n<p>Abra <code>arquivo.txt</code>. Você verá algo assim:\n    <code>Conteúdo original\n    &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n    Alteração da Feature A\n    =======\n    Alteração da Feature B (CONFLITO)\n    &gt;&gt;&gt;&gt;&gt;&gt;&gt; feature-b</code></p>\n</li>\n<li>\n<p>Edite o arquivo para deixar como você quer (ex: mantendo ambos ou escolhendo um).\n    <code>Conteúdo original\n    Alteração da Feature A\n    Alteração da Feature B (CONFLITO)</code></p>\n</li>\n<li>\n<p>Finalize o merge:\n    <code>bash\n    git add arquivo.txt\n    git commit -m \"Merge branch feature-b: resolvendo conflitos\"</code></p>\n</li>\n</ol>\n<p>Parabéns! Você resolveu seu primeiro conflito de merge.</p>",
        "examples": [],
        "summary": "",
        "estimated_time_minutes": 30
    },
    {
        "id": "01-internals-theory",
        "course_id": "git-avancado",
        "title": "Módulo 03/01: Git Internals - Por Baixo do Capô",
        "order": 5,
        "description": "Lição do módulo 01-internals",
        "learning_objectives": [],
        "key_concepts": [],
        "content": "<h1>Módulo 03/01: Git Internals - Por Baixo do Capô</h1>\n<h2>Introdução</h2>\n<p>Muitos desenvolvedores usam o Git apenas decorando comandos. Para dominar a ferramenta e resolver problemas complexos, é fundamental entender como o Git armazena e processa dados. Diferente de outros VCS que armazenam diferenças (deltas), o Git é um <strong>sistema de arquivos endereçável por conteúdo</strong>.</p>\n<h2>1. O Diretório <code>.git</code></h2>\n<p>Toda a mágica acontece dentro da pasta oculta <code>.git</code> na raiz do seu projeto.\nPrincipais componentes:</p>\n<ul>\n<li><code>HEAD</code>: Um ponteiro para o branch atual.</li>\n<li><code>config</code>: Configurações locais do projeto.</li>\n<li><code>objects/</code>: O banco de dados de objetos (onde o conteúdo real vive).</li>\n<li><code>refs/</code>: Ponteiros para commits (heads/branches, tags, remotes).</li>\n</ul>\n<h2>2. Os Objetos do Git</h2>\n<p>O Git armazena dados em quatro tipos principais de objetos. Cada objeto é identificado por um hash SHA-1 de 40 caracteres, calculado com base no seu conteúdo.</p>\n<h3>Blob (Binary Large Object)</h3>\n<p>Armazena o <strong>conteúdo</strong> de um arquivo. Não contém o nome do arquivo, apenas os dados.\n<em>Se você tiver dois arquivos com o mesmo conteúdo em pastas diferentes, o Git armazenará apenas um blob.</em></p>\n<h3>Tree</h3>\n<p>Representa diretórios. Uma Tree mapeia nomes de arquivos para Blobs e nomes de subdiretórios para outras Trees. É o que dá estrutura ao projeto.</p>\n<h3>Commit</h3>\n<p>O objeto principal que une tudo. Contém:\n-   Ponteiro para a Tree raiz do projeto naquele momento.\n-   Ponteiro para o(s) commit(s) pai(s).\n-   Metadados (autor, data, mensagem).</p>\n<h3>Tag</h3>\n<p>Um rótulo fixo para um commit específico (geralmente usado para releases). Pode conter uma mensagem e assinatura GPG (Annotated Tag).</p>\n<h2>3. Endereçamento por Conteúdo</h2>\n<p>No Git, o nome do arquivo no banco de dados <code>objects/</code> é o hash do seu conteúdo.\nIsso significa que:\n1.  A integridade é garantida criptograficamente.\n2.  Desduplicação é automática.</p>",
        "examples": [],
        "summary": "",
        "estimated_time_minutes": 30
    },
    {
        "id": "01-internals-lab-objects",
        "course_id": "git-avancado",
        "title": "Laboratório 01: Explorando Objetos do Git",
        "order": 6,
        "description": "Lição do módulo 01-internals",
        "learning_objectives": [],
        "key_concepts": [],
        "content": "<h1>Laboratório 01: Explorando Objetos do Git</h1>\n<p><strong>Objetivo</strong>: Manipular diretamente o banco de dados do Git (encanamento/plumbing) para entender como Blobs, Trees e Commits são formados.</p>\n<h2>Passo 1: O Banco de Dados de Objetos</h2>\n<ol>\n<li>\n<p>Crie um repositório limpo:\n    <code>bash\n    mkdir lab-internals\n    cd lab-internals\n    git init</code></p>\n</li>\n<li>\n<p>Explore a pasta objects:\n    <code>bash\n    find .git/objects -type f</code>\n    <em>Deve estar vazia (exceto pack/info).</em></p>\n</li>\n</ol>\n<h2>Passo 2: Criando um Blob Manualmente</h2>\n<p>O comando <code>git hash-object</code> calcula o hash e opcionalmente grava o objeto.</p>\n<ol>\n<li>\n<p>Grave uma string no banco de dados:\n    <code>bash\n    echo \"conteúdo secreto\" | git hash-object -w --stdin</code>\n    <em>O comando retornará um hash, ex: <code>d670460...</code></em></p>\n</li>\n<li>\n<p>Verifique a pasta objects novamente:\n    <code>bash\n    find .git/objects -type f</code>\n    <em>Você verá um arquivo criado com os 2 primeiros caracteres do hash como pasta e o restante como nome.</em></p>\n</li>\n</ol>\n<h2>Passo 3: Lendo o Conteúdo</h2>\n<p>O comando <code>git cat-file</code> investiga objetos.</p>\n<ol>\n<li>\n<p>Verifique o tipo do objeto (use os primeiros 6 chars do hash retornado acima):\n    <code>bash\n    git cat-file -t [HASH]</code>\n    <em>Deve retornar <code>blob</code>.</em></p>\n</li>\n<li>\n<p>Leia o conteúdo:\n    <code>bash\n    git cat-file -p [HASH]</code>\n    <em>Deve retornar \"conteúdo secreto\".</em></p>\n</li>\n</ol>\n<h2>Passo 4: Explorando Commits Existentes</h2>\n<p>Vamos ver como um commit real se parece.</p>\n<ol>\n<li>\n<p>Faça um commit normal:\n    <code>bash\n    echo \"Olá\" &gt; arquivo.txt\n    git add arquivo.txt\n    git commit -m \"Commit de teste\"</code></p>\n</li>\n<li>\n<p>Descubra o hash do commit atual (HEAD):\n    <code>bash\n    git rev-parse HEAD</code></p>\n</li>\n<li>\n<p>Inspecione o commit:\n    <code>bash\n    git cat-file -p [HASH_DO_COMMIT]</code>\n    <em>Observe que ele aponta para uma <code>tree</code> e contém autor/committer.</em></p>\n</li>\n<li>\n<p>Inspecione a Tree apontada pelo commit:\n    <code>bash\n    git cat-file -p [HASH_DA_TREE]</code>\n    <em>Observe que ela mapeia <code>arquivo.txt</code> para um hash de <code>blob</code>.</em></p>\n</li>\n<li>\n<p>Inspecione o Blob final:\n    <code>bash\n    git cat-file -p [HASH_DO_BLOB]</code>\n    <em>Deve ser \"Olá\".</em></p>\n</li>\n</ol>",
        "examples": [],
        "summary": "",
        "estimated_time_minutes": 30
    },
    {
        "id": "02-advanced-history-theory-rebase",
        "course_id": "git-avancado",
        "title": "Módulo 03/02: Manipulação Avançada de Histórico",
        "order": 7,
        "description": "Lição do módulo 02-advanced-history",
        "learning_objectives": [],
        "key_concepts": [],
        "content": "<h1>Módulo 03/02: Manipulação Avançada de Histórico</h1>\n<h2>Introdução</h2>\n<p>Um histórico limpo conta uma história clara sobre a evolução do projeto. O Git oferece ferramentas poderosas para reescrever essa história, mas é preciso usá-las com cuidado (\"Com grandes poderes...\").</p>\n<h2>1. Reescrevendo com Rebase Interativo</h2>\n<p>O <code>git rebase -i</code> (interativo) permite editar uma série de commits. Você pode:\n-   <strong>reword</strong>: Alterar a mensagem do commit.\n-   <strong>edit</strong>: Parar para alterar o conteúdo do commit.\n-   <strong>squash/fixup</strong>: Fundir o commit no anterior.\n-   <strong>drop</strong>: Remover o commit.</p>\n<div class=\"codehilite\"><pre><span></span><code>git<span class=\"w\"> </span>rebase<span class=\"w\"> </span>-i<span class=\"w\"> </span>HEAD~3\n</code></pre></div>\n\n<p><em>Isso abre um editor com os últimos 3 commits para você manipular.</em></p>\n<h2>2. Emendando o Último Commit</h2>\n<p>Se você esqueceu de adicionar um arquivo ou errou na mensagem do último commit (e ainda não fez push):</p>\n<div class=\"codehilite\"><pre><span></span><code>git<span class=\"w\"> </span>commit<span class=\"w\"> </span>--amend\n</code></pre></div>\n\n<p>Isso substitui o último commit por um novo.</p>\n<h2>3. Cherry-Picking</h2>\n<p>Às vezes você precisa aplicar apenas um commit específico de outro branch no seu.</p>\n<div class=\"codehilite\"><pre><span></span><code>git<span class=\"w\"> </span>cherry-pick<span class=\"w\"> </span><span class=\"o\">[</span>HASH_DO_COMMIT<span class=\"o\">]</span>\n</code></pre></div>\n\n<h2>4. O Reflog: Sua Rede de Segurança</h2>\n<p>Quando você faz rebase ou reset, parece que você \"perdeu\" commits. Na verdade, o Git mantém um registro de onde HEAD esteve nos últimos dias.</p>\n<div class=\"codehilite\"><pre><span></span><code>git<span class=\"w\"> </span>reflog\n</code></pre></div>\n\n<p>Você pode recuperar qualquer estado anterior:</p>\n<div class=\"codehilite\"><pre><span></span><code>git<span class=\"w\"> </span>reset<span class=\"w\"> </span>--hard<span class=\"w\"> </span>HEAD@<span class=\"o\">{</span><span class=\"m\">12</span><span class=\"o\">}</span>\n</code></pre></div>\n\n<h2>5. Limpando Histórico (BFG / Filter-Repo)</h2>\n<p>Se você acidentalmente comitou senhas ou arquivos gigantes, ferramentas como <code>git-filter-repo</code> (o sucessor do <code>filter-branch</code>) são necessárias para reescrever todo o histórico e remover esses objetos.</p>\n<blockquote>\n<p><strong>Aviso</strong>: Reescrever histórico de branches públicos quebra o repositório para outros colaboradores. Só faça isso em branches locais ou se tiver coordenado com a equipe.</p>\n</blockquote>",
        "examples": [],
        "summary": "",
        "estimated_time_minutes": 30
    },
    {
        "id": "02-advanced-history-lab-interactive-rebase",
        "course_id": "git-avancado",
        "title": "Laboratório 02: Cirurgia de Histórico",
        "order": 8,
        "description": "Lição do módulo 02-advanced-history",
        "learning_objectives": [],
        "key_concepts": [],
        "content": "<h1>Laboratório 02: Cirurgia de Histórico</h1>\n<p><strong>Objetivo</strong>: Usar <code>rebase -i</code> para limpar um histórico bagunçado e usar <code>reflog</code> para recuperar um erro intencional.</p>\n<h2>Passo 1: Criando uma Bagunça</h2>\n<ol>\n<li>Crie um novo repositório ou branch para o lab.</li>\n<li>\n<p>Crie uma série de commits \"ruins\":</p>\n<p>```bash\necho \"Funcionalidade A parte 1\" &gt; func.txt\ngit add func.txt\ngit commit -m \"WIP: começando func A\"</p>\n<p>echo \"Funcionalidade A parte 2\" &gt;&gt; func.txt\ngit add func.txt\ngit commit -m \"continuando func A\"</p>\n<p>echo \"Erro corrigido\" &gt;&gt; func.txt\ngit add func.txt\ngit commit -m \"fix: corrigindo typo no commit anterior\"\n```</p>\n</li>\n</ol>\n<h2>Passo 2: Limpando com Squash</h2>\n<p>Queremos transformar esses 3 commits em um único commit limpo \"feat: Implementar Funcionalidade A\".</p>\n<ol>\n<li>\n<p>Inicie o rebase interativo:\n    <code>bash\n    git rebase -i HEAD~3</code></p>\n</li>\n<li>\n<p>No editor, deixe o primeiro como <code>pick</code>, e mude os outros dois para <code>squash</code> (ou <code>s</code>):\n    <code>pick [HASH1] WIP: começando func A\n    squash [HASH2] continuando func A\n    squash [HASH3] fix: corrigindo typo no commit anterior</code></p>\n</li>\n<li>\n<p>Salve e feche. O Git abrirá outro editor para definir a mensagem final.</p>\n</li>\n<li>Apague as mensagens antigas e escreva apenas:\n    <code>feat: Implementar Funcionalidade A</code></li>\n<li>Salve e feche.</li>\n<li>Verifique o log: <code>git log --oneline</code>. Deve haver apenas um commit novo.</li>\n</ol>\n<h2>Passo 3: Simulando um Desastre</h2>\n<ol>\n<li>Vamos \"acidentalmente\" destruir nosso trabalho.\n    <code>bash\n    git reset --hard HEAD~1</code>\n    <em>Agora o commit da funcionalidade sumiu do log.</em></li>\n</ol>\n<h2>Passo 4: Recuperando com Reflog</h2>\n<ol>\n<li>\n<p>Veja o histórico de ações:\n    <code>bash\n    git reflog</code>\n    <em>Procure uma linha como <code>HEAD@{1}: rebase -i (finish): returning to refs/heads/...</code></em></p>\n</li>\n<li>\n<p>Recupere o commit perdido (substitua o índice):\n    <code>bash\n    git reset --hard HEAD@{1}</code></p>\n</li>\n<li>\n<p>Verifique se o arquivo voltou:\n    <code>bash\n    cat func.txt</code></p>\n</li>\n</ol>",
        "examples": [],
        "summary": "",
        "estimated_time_minutes": 30
    },
    {
        "id": "03-workflows-theory-gitflow",
        "course_id": "git-avancado",
        "title": "Módulo 03/03: Workflows e Estratégias",
        "order": 9,
        "description": "Lição do módulo 03-workflows",
        "learning_objectives": [],
        "key_concepts": [],
        "content": "<h1>Módulo 03/03: Workflows e Estratégias</h1>\n<h2>Introdução</h2>\n<p>Não basta saber os comandos; é preciso saber como trabalhar em equipe. Git Workflows são \"contratos\" de como a equipe usará branches e merges para entregar software.</p>\n<h2>1. Git Flow (O Clássico)</h2>\n<p>Popularizado por Vincent Driessen, é ideal para projetos com ciclos de release bem definidos (versões 1.0, 1.1, etc).</p>\n<p><strong>Estrutura de Branches:</strong>\n-   <code>master</code>: Histórico de produção. Apenas releases oficiais.\n-   <code>develop</code>: Branch de integração principal.\n-   <code>feature/*</code>: Novas funcionalidades. Nascem e morrem na <code>develop</code>.\n-   <code>release/*</code>: Preparação para nova versão (apenas bugfixes). Merge na <code>master</code> e <code>develop</code>.\n-   <code>hotfix/*</code>: Correção urgente em produção. Nasce da <code>master</code>, merge em <code>master</code> e <code>develop</code>.</p>\n<h2>2. Trunk-Based Development (O Moderno)</h2>\n<p>Focado em integração contínua (CI/CD) e velocidade.</p>\n<p><strong>Princípios:</strong>\n-   Branch principal (<code>trunk</code> ou <code>main</code>) está sempre \"deployável\".\n-   Branches de feature (se existirem) duram no máximo 1-2 dias.\n-   Muitas vezes comita-se direto na <code>main</code> (se houver testes robustos).\n-   Se a feature não está pronta, usa-se <strong>Feature Flags</strong> para escondê-la, em vez de isolar o código em branch.</p>\n<h2>3. GitHub Flow</h2>\n<p>Uma simplificação do Git Flow, muito usada em web apps.</p>\n<ol>\n<li>Branch <code>main</code> é deployável.</li>\n<li>Crie um branch descritivo (<code>new-oauth</code>) a partir da <code>main</code>.</li>\n<li>Faça commits.</li>\n<li>Abra um <strong>Pull Request</strong> para discussão e review.</li>\n<li>Merge na <code>main</code> e deploy imediato.</li>\n</ol>\n<h2>4. Feature Flags</h2>\n<p>Desacoplar <strong>Deploy</strong> (instalação de código) de <strong>Release</strong> (liberação para usuário).\nO código entra em produção desligado (<code>if flag_enabled: new_feature()</code>) e é ligado gradualmente. Isso elimina a necessidade de branches de longa duração.</p>",
        "examples": [],
        "summary": "",
        "estimated_time_minutes": 30
    },
    {
        "id": "03-workflows-lab-workflow-sim",
        "course_id": "git-avancado",
        "title": "Laboratório 03: Simulação de Git Flow",
        "order": 10,
        "description": "Lição do módulo 03-workflows",
        "learning_objectives": [],
        "key_concepts": [],
        "content": "<h1>Laboratório 03: Simulação de Git Flow</h1>\n<p><strong>Objetivo</strong>: Simular manualmente o ciclo de vida de uma release usando o modelo Git Flow.</p>\n<h2>Passo 1: Setup dos Branches Principais</h2>\n<ol>\n<li>Crie um repositório para o laboratório (se já não estiver em um).</li>\n<li>Garanta que a <code>master</code> existe (commit inicial).</li>\n<li>Crie a branch <code>develop</code>:\n    <code>bash\n    git branch develop\n    git push -u origin develop # se houver remote</code></li>\n</ol>\n<h2>Passo 2: Iniciando uma Feature</h2>\n<ol>\n<li>Crie uma feature a partir da <code>develop</code>:\n    <code>bash\n    git checkout develop\n    git checkout -b feature/login-page</code></li>\n<li>Trabalhe na feature:\n    <code>bash\n    echo \"Login Page Code\" &gt; login.html\n    git add .\n    git commit -m \"feat: login page basics\"</code></li>\n<li>Finalize a feature (merge na develop):\n    <code>bash\n    git checkout develop\n    git merge --no-ff feature/login-page</code>\n    <em><code>--no-ff</code> cria um commit de merge explícito, preservando a história da feature.</em></li>\n</ol>\n<h2>Passo 3: Preparando uma Release</h2>\n<p>Imagine que temos features suficientes para a versão 1.0.</p>\n<ol>\n<li>Crie a release branch a partir da <code>develop</code>:\n    <code>bash\n    git checkout -b release/1.0</code></li>\n<li>Faça ajustes finais (bump de versão, docs, bugfixes leves):\n    <code>bash\n    echo \"v1.0\" &gt; version.txt\n    git commit -am \"chore: bump version to 1.0\"</code></li>\n</ol>\n<h2>Passo 4: Finalizando a Release</h2>\n<ol>\n<li>\n<p>Merge na <code>master</code>:\n    <code>bash\n    git checkout master\n    git merge --no-ff release/1.0\n    git tag -a v1.0 -m \"Versão 1.0 Oficial\"</code></p>\n</li>\n<li>\n<p>Merge de volta na <code>develop</code> (para que ela saiba das mudanças da release):\n    <code>bash\n    git checkout develop\n    git merge --no-ff release/1.0</code></p>\n</li>\n<li>\n<p>Apague o branch de release:\n    <code>bash\n    git branch -d release/1.0</code></p>\n</li>\n</ol>\n<h2>Passo 5: Simulando um Hotfix</h2>\n<p>Ops! Bug crítico em produção na v1.0.</p>\n<ol>\n<li>\n<p>Crie o hotfix a partir da <code>master</code> (a versão estável):\n    <code>bash\n    git checkout master\n    git checkout -b hotfix/conserte-login</code></p>\n</li>\n<li>\n<p>Corrija o bug:\n    <code>bash\n    echo \"Bug corrigido\" &gt;&gt; login.html\n    git commit -am \"fix: correção crítica no login\"</code></p>\n</li>\n<li>\n<p>Finalize o hotfix (merge em master E develop):\n    ```bash\n    git checkout master\n    git merge --no-ff hotfix/conserte-login\n    git tag v1.0.1</p>\n<p>git checkout develop\ngit merge --no-ff hotfix/conserte-login\n```</p>\n</li>\n</ol>",
        "examples": [],
        "summary": "",
        "estimated_time_minutes": 30
    },
    {
        "id": "04-tools-theory-hooks",
        "course_id": "git-avancado",
        "title": "Módulo 03/04: Ferramentas Avançadas (Hooks, Bisect)",
        "order": 11,
        "description": "Lição do módulo 04-tools",
        "learning_objectives": [],
        "key_concepts": [],
        "content": "<h1>Módulo 03/04: Ferramentas Avançadas (Hooks, Bisect)</h1>\n<h2>Introdução</h2>\n<p>O Git vai muito além de add, commit e push. Ele possui ferramentas internas para automação e depuração que podem salvar horas de trabalho.</p>\n<h2>1. Git Hooks</h2>\n<p>Hooks são scripts executados automaticamente pelo Git antes ou depois de eventos como commit, push e receive. Eles vivem em <code>.git/hooks</code>.</p>\n<h3>Tipos Comuns</h3>\n<ul>\n<li><strong>pre-commit</strong>: Roda antes do commit ser criado. Usado para linters, formatadores e testes rápidos.</li>\n<li><strong>commit-msg</strong>: Valida a mensagem do commit (ex: exigir padrão \"feat: ...\").</li>\n<li><strong>pre-push</strong>: Roda antes do push. Usado para rodar a suíte completa de testes.</li>\n</ul>\n<p>Para criar um hook, basta criar um arquivo executável no diretório hooks com o nome do evento.</p>\n<h2>2. Git Bisect: Caçando Bugs com Busca Binária</h2>\n<p>Imagine que o código funcionava na versão 1.0, mas quebrou na 2.0 (que tem 100 commits entre elas). Como achar o commit culpado?</p>\n<p>O <code>git bisect</code> automatiza a busca binária.\n1.  Você marca o commit atual como <code>bad</code>.\n2.  Você marca um commit antigo como <code>good</code>.\n3.  O Git faz checkout na metade do caminho.\n4.  Você testa e diz se está <code>good</code> ou <code>bad</code>.\n5.  O Git repete o processo até isolar o commit exato.</p>\n<h2>3. Git Blame</h2>\n<p>Para saber quem escreveu (e quando) cada linha de um arquivo.</p>\n<div class=\"codehilite\"><pre><span></span><code>git<span class=\"w\"> </span>blame<span class=\"w\"> </span>arquivo.py\n</code></pre></div>\n\n<p>Útil para entender o contexto de uma mudança, não apenas para \"culpar\" alguém.</p>",
        "examples": [],
        "summary": "",
        "estimated_time_minutes": 30
    },
    {
        "id": "04-tools-lab-bisect",
        "course_id": "git-avancado",
        "title": "Laboratório 04: Detetive Git com Bisect",
        "order": 12,
        "description": "Lição do módulo 04-tools",
        "learning_objectives": [],
        "key_concepts": [],
        "content": "<h1>Laboratório 04: Detetive Git com Bisect</h1>\n<p><strong>Objetivo</strong>: Usar o <code>git bisect</code> para encontrar um commit que inseriu um bug no código.</p>\n<h2>Passo 1: Preparando o Cenário</h2>\n<ol>\n<li>Crie um repositório para o lab.</li>\n<li>\n<p>Crie um script Python simples <code>app.py</code>:\n    ```python\n    def soma(a, b):\n        return a + b</p>\n<p>print(f\"2 + 2 = {soma(2, 2)}\")\n```\nCommit inicial: \"feat: add soma function\" (GOOD).</p>\n</li>\n<li>\n<p>Faça vários commits neutros (ex: atualizando docs, README).</p>\n</li>\n<li>\n<p>Faça o <strong>commit do bug</strong>:\n    Altere <code>app.py</code> para:\n    <code>python\n    def soma(a, b):\n        return a * b  # BUG! Multiplicação em vez de soma</code>\n    Commit: \"refactor: optimize math engine\".</p>\n</li>\n<li>\n<p>Faça mais commits neutros depois disso.</p>\n</li>\n</ol>\n<h2>Passo 2: Iniciando a Caçada</h2>\n<p>Execute o script. Você verá <code>2 + 2 = 4</code> (ops, 2*2 também é 4, mau exemplo!).\nVamos mudar para: <code>soma(2, 3)</code>. O esperado é 5, mas o bug deve dar 6.</p>\n<ol>\n<li>\n<p>Verifique o erro na HEAD:\n    Execute e veja o resultado errado.</p>\n</li>\n<li>\n<p>Inicie o bisect:\n    <code>bash\n    git bisect start\n    git bisect bad  # A versão atual (HEAD) está ruim</code></p>\n</li>\n<li>\n<p>Vá para o commit inicial e verifique se estava bom:\n    <code>bash\n    git checkout [HASH_INICIAL]\n    python3 app.py # Verifica se 2+3=5\n    git bisect good # A versão antiga estava boa</code></p>\n</li>\n</ol>\n<h2>Passo 3: O Processo de Bisect</h2>\n<p>O Git agora fará checkout um commit no meio do caminho.</p>\n<ol>\n<li>Teste a versão atual:\n    <code>bash\n    python3 app.py</code></li>\n<li>\n<p>Diga ao Git o resultado:</p>\n<ul>\n<li>Se o resultado for 5 (correto): <code>git bisect good</code></li>\n<li>Se o resultado for 6 (errado): <code>git bisect bad</code></li>\n</ul>\n</li>\n<li>\n<p>Repita até o Git dizer:\n    <code>[HASH] is the first bad commit</code></p>\n</li>\n</ol>\n<h2>Passo 4: Finalizando</h2>\n<ol>\n<li>\n<p>Saia do modo bisect:\n    <code>bash\n    git bisect reset</code></p>\n</li>\n<li>\n<p>Agora você sabe quem quebrou o código!</p>\n</li>\n</ol>",
        "examples": [],
        "summary": "",
        "estimated_time_minutes": 30
    },
    {
        "id": "05-complex-structures-theory-lfs",
        "course_id": "git-avancado",
        "title": "Módulo 03/05: Git LFS (Large File Storage)",
        "order": 13,
        "description": "Lição do módulo 05-complex-structures",
        "learning_objectives": [],
        "key_concepts": [],
        "content": "<h1>Módulo 03/05: Git LFS (Large File Storage)</h1>\n<h2>Introdução</h2>\n<p>O Git não foi feito para arquivos binários grandes (vídeos, PSDs, modelos 3D). Como ele salva o histórico completo localmente, repositórios com binários ficam gigantescos rapidamente.</p>\n<h2>1. O Problema</h2>\n<p>Se você comita um arquivo de 100MB e depois o altera, o repositório cresce 200MB. Mesmo que você apague o arquivo no commit seguinte, ele continua no histórico (<code>.git/objects</code>), ocupando espaço para sempre.</p>\n<h2>2. A Solução: Git LFS</h2>\n<p>O Git LFS é uma extensão que substitui arquivos grandes por ponteiros de texto dentro do Git, enquanto armazena o conteúdo real em um servidor remoto especializado.</p>\n<h3>Como Funciona</h3>\n<ol>\n<li>Você diz ao Git LFS para rastrear <code>*.psd</code>.</li>\n<li>Quando você adiciona um PSD, o LFS intercepta.</li>\n<li>O Git normal vê apenas um arquivo de texto pequeno (o ponteiro).</li>\n<li>O servidor LFS armazena o blob grande.</li>\n</ol>\n<h2>3. Comandos Básicos</h2>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c1\"># 1. Instalar (uma vez por máquina)</span>\ngit<span class=\"w\"> </span>lfs<span class=\"w\"> </span>install\n\n<span class=\"c1\"># 2. Rastrear arquivos (uma vez por projeto)</span>\ngit<span class=\"w\"> </span>lfs<span class=\"w\"> </span>track<span class=\"w\"> </span><span class=\"s2\">&quot;*.psd&quot;</span>\n\n<span class=\"c1\"># 3. Isso cria um .gitattributes, que deve ser comitado</span>\ngit<span class=\"w\"> </span>add<span class=\"w\"> </span>.gitattributes\n</code></pre></div>\n\n<p>Depois disso, use <code>git add</code> e <code>git commit</code> normalmente. O LFS cuida do resto.</p>",
        "examples": [],
        "summary": "",
        "estimated_time_minutes": 30
    },
    {
        "id": "05-complex-structures-theory-submodules",
        "course_id": "git-avancado",
        "title": "Módulo 03/05: Estruturas Complexas (Submódulos)",
        "order": 14,
        "description": "Lição do módulo 05-complex-structures",
        "learning_objectives": [],
        "key_concepts": [],
        "content": "<h1>Módulo 03/05: Estruturas Complexas (Submódulos)</h1>\n<h2>Introdução</h2>\n<p>À medida que os projetos crescem, surge a necessidade de compartilhar código entre repositórios. O Git oferece <strong>Submodules</strong> (e Subtrees) para resolver isso.</p>\n<h2>1. O que são Submodules?</h2>\n<p>Um submódulo permite manter um repositório Git dentro de outro repositório Git. O projeto principal (superprojeto) mantém apenas um link para um commit específico do submódulo.</p>\n<h3>Conceitos Chave</h3>\n<ul>\n<li>O submódulo é um repositório completo e independente.</li>\n<li>O superprojeto não rastreia o <em>conteúdo</em> do submódulo, apenas aponta para um HASH.</li>\n<li>Quando você clona o superprojeto, os submódulos vêm vazios por padrão.</li>\n</ul>\n<h2>2. Comandos Essenciais</h2>\n<h3>Adicionar um Submódulo</h3>\n<div class=\"codehilite\"><pre><span></span><code>git<span class=\"w\"> </span>submodule<span class=\"w\"> </span>add<span class=\"w\"> </span>https://github.com/exemplo/lib.gitlibs/lib\n</code></pre></div>\n\n<h3>Clonar com Submódulos</h3>\n<div class=\"codehilite\"><pre><span></span><code>git<span class=\"w\"> </span>clone<span class=\"w\"> </span>--recursive<span class=\"w\"> </span>&lt;url-do-superprojeto&gt;\n</code></pre></div>\n\n<p>Ou, se já clonou:</p>\n<div class=\"codehilite\"><pre><span></span><code>git<span class=\"w\"> </span>submodule<span class=\"w\"> </span>update<span class=\"w\"> </span>--init<span class=\"w\"> </span>--recursive\n</code></pre></div>\n\n<h3>Atualizar Submódulos</h3>\n<p>Se o repositório remoto do submódulo mudou:</p>\n<div class=\"codehilite\"><pre><span></span><code>git<span class=\"w\"> </span>submodule<span class=\"w\"> </span>update<span class=\"w\"> </span>--remote\n</code></pre></div>\n\n<h2>3. Cuidados</h2>\n<ul>\n<li><strong>Esquecer de atualizar</strong>: Se você mudar o commit do submódulo mas não comitar no superprojeto, outros não verão a mudança.</li>\n<li><strong>Complexidade</strong>: Git Submodules são famosos por serem difíceis de gerenciar. Use apenas se necessário (monorepos ou libs compartilhadas privadas).</li>\n</ul>",
        "examples": [],
        "summary": "",
        "estimated_time_minutes": 30
    }
]