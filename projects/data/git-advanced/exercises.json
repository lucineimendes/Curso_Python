[
    {
        "id": "ex-git-basic-config-1",
        "lesson_id": "01-basic-theory-basics",
        "title": "Configurando o Git",
        "description": "Configure sua identidade no Git definindo seu nome de usuário e email.",
        "difficulty": "Fácil",
        "order": 1,
        "instructions": "Use os comandos git config para definir user.name e user.email. Simule a saída dos comandos imprimindo as configurações.",
        "initial_code": "# Simule a configuração do Git\n# Imprima as linhas de comando que você usaria para configurar:\n# 1. Seu nome de usuário\n# 2. Seu email\n# print(\"git config --global user.name 'Seu Nome'\")\n# print(\"git config --global user.email 'seu@email.com'\")",
        "solution_code": "print(\"git config --global user.name 'João Silva'\")\nprint(\"git config --global user.email 'joao@exemplo.com'\")",
        "test_code": "assert \"git config --global user.name\" in output and \"git config --global user.email\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-git-basic-init-1",
        "lesson_id": "01-basic-theory-basics",
        "title": "Inicializando um Repositório",
        "description": "Simule a inicialização de um repositório Git e a criação do primeiro commit.",
        "difficulty": "Fácil",
        "order": 2,
        "instructions": "Imprima a sequência de comandos necessários para: 1) Inicializar um repositório, 2) Adicionar um arquivo, 3) Fazer o primeiro commit.",
        "initial_code": "# Simule a sequência de comandos para inicializar um repositório\n# e fazer o primeiro commit\n# print(\"git init\")\n# print(\"git add arquivo.txt\")\n# print(\"git commit -m 'Mensagem'\")",
        "solution_code": "print(\"git init\")\nprint(\"git add README.md\")\nprint(\"git commit -m 'Primeiro commit: adiciona README'\")",
        "test_code": "assert \"git init\" in output and \"git add\" in output and \"git commit\" in output and \"-m\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-git-basic-status-1",
        "lesson_id": "01-basic-theory-basics",
        "title": "Entendendo o Ciclo de Vida",
        "description": "Demonstre o entendimento dos três estados principais do Git: Working Directory, Staging Area e Repository.",
        "difficulty": "Médio",
        "order": 3,
        "instructions": "Imprima uma explicação dos três estados e qual comando move arquivos entre eles.",
        "initial_code": "# Explique os três estados do Git e os comandos que movem arquivos entre eles\n# print(\"Working Directory -> Staging Area: git add\")\n# print(\"Staging Area -> Repository: git commit\")",
        "solution_code": "print(\"Working Directory: onde você edita os arquivos\")\nprint(\"Staging Area: onde você prepara mudanças para commit\")\nprint(\"Repository: onde o Git armazena o histórico\")\nprint(\"\")\nprint(\"Working Directory -> Staging Area: git add\")\nprint(\"Staging Area -> Repository: git commit\")",
        "test_code": "assert \"Working Directory\" in output and \"Staging Area\" in output and \"Repository\" in output and \"git add\" in output and \"git commit\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-git-basic-gitignore-1",
        "lesson_id": "01-basic-lab-first-commit",
        "title": "Criando um .gitignore",
        "description": "Crie um arquivo .gitignore que ignore arquivos temporários do Python e arquivos de ambiente.",
        "difficulty": "Fácil",
        "order": 4,
        "instructions": "Imprima o conteúdo de um arquivo .gitignore que ignore: __pycache__/, *.pyc, .env e *.log",
        "initial_code": "# Crie o conteúdo de um arquivo .gitignore\n# print(\"# Arquivos Python\")\n# print(\"__pycache__/\")\n# ...",
        "solution_code": "print(\"# Arquivos temporários do Python\")\nprint(\"__pycache__/\")\nprint(\"*.pyc\")\nprint(\"\")\nprint(\"# Arquivos de ambiente\")\nprint(\".env\")\nprint(\"\")\nprint(\"# Logs\")\nprint(\"*.log\")",
        "test_code": "assert \"__pycache__\" in output and \"*.pyc\" in output and \".env\" in output and \"*.log\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-git-inter-branch-1",
        "lesson_id": "02-intermediario-theory-branches",
        "title": "Criando e Trocando de Branches",
        "description": "Demonstre como criar um novo branch e trocar para ele.",
        "difficulty": "Fácil",
        "order": 5,
        "instructions": "Imprima os comandos para: 1) Criar um branch chamado 'feature-login', 2) Trocar para esse branch, 3) Criar e trocar em um único comando.",
        "initial_code": "# Imprima os comandos para trabalhar com branches\n# print(\"git branch feature-login\")\n# print(\"git checkout feature-login\")\n# print(\"git checkout -b feature-login\")",
        "solution_code": "print(\"# Criar um branch\")\nprint(\"git branch feature-login\")\nprint(\"\")\nprint(\"# Trocar para o branch\")\nprint(\"git checkout feature-login\")\nprint(\"\")\nprint(\"# Criar e trocar em um comando\")\nprint(\"git checkout -b feature-login\")",
        "test_code": "assert \"git branch feature-login\" in output and \"git checkout feature-login\" in output and \"git checkout -b\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-git-inter-merge-1",
        "lesson_id": "02-intermediario-theory-branches",
        "title": "Fazendo Merge de Branches",
        "description": "Simule o processo de merge de um branch de feature no branch principal.",
        "difficulty": "Médio",
        "order": 6,
        "instructions": "Imprima a sequência de comandos para: 1) Voltar para o branch main, 2) Fazer merge do branch feature-login.",
        "initial_code": "# Simule o processo de merge\n# print(\"git checkout main\")\n# print(\"git merge feature-login\")",
        "solution_code": "print(\"# Voltar para o branch principal\")\nprint(\"git checkout main\")\nprint(\"\")\nprint(\"# Fazer merge do branch de feature\")\nprint(\"git merge feature-login\")",
        "test_code": "assert \"git checkout main\" in output and \"git merge feature-login\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-git-inter-conflict-1",
        "lesson_id": "02-intermediario-lab-merge-conflict",
        "title": "Resolvendo Conflitos de Merge",
        "description": "Demonstre o entendimento de como resolver conflitos de merge.",
        "difficulty": "Médio",
        "order": 7,
        "instructions": "Imprima os passos para resolver um conflito: 1) Editar o arquivo conflituoso, 2) Adicionar o arquivo resolvido, 3) Finalizar o merge.",
        "initial_code": "# Imprima os passos para resolver um conflito\n# print(\"1. Editar o arquivo e remover os marcadores de conflito\")\n# print(\"2. git add arquivo.txt\")\n# print(\"3. git commit -m 'Resolve conflito'\")",
        "solution_code": "print(\"Passos para resolver conflito de merge:\")\nprint(\"\")\nprint(\"1. Abrir o arquivo conflituoso e editar\")\nprint(\"   Remover marcadores: <<<<<<< HEAD, =======, >>>>>>> branch\")\nprint(\"\")\nprint(\"2. Adicionar o arquivo resolvido\")\nprint(\"   git add arquivo.txt\")\nprint(\"\")\nprint(\"3. Finalizar o merge\")\nprint(\"   git commit -m 'Resolve conflito entre branches'\")",
        "test_code": "assert \"git add\" in output and \"git commit\" in output and (\"conflito\" in output.lower() or \"conflict\" in output.lower()) and (\"<<<\" in output or \"marcador\" in output.lower())",
        "level": "avançado"
    },
    {
        "id": "ex-git-inter-remote-1",
        "lesson_id": "02-intermediario-theory-branches",
        "title": "Trabalhando com Repositórios Remotos",
        "description": "Demonstre os comandos básicos para trabalhar com repositórios remotos.",
        "difficulty": "Médio",
        "order": 8,
        "instructions": "Imprima os comandos para: 1) Adicionar um remoto chamado 'origin', 2) Enviar mudanças para o remoto, 3) Trazer mudanças do remoto.",
        "initial_code": "# Imprima os comandos para trabalhar com remotos\n# print(\"git remote add origin https://github.com/usuario/repo.git\")\n# print(\"git push -u origin main\")\n# print(\"git pull\")",
        "solution_code": "print(\"# Adicionar repositório remoto\")\nprint(\"git remote add origin https://github.com/usuario/repo.git\")\nprint(\"\")\nprint(\"# Enviar mudanças (primeira vez)\")\nprint(\"git push -u origin main\")\nprint(\"\")\nprint(\"# Enviar mudanças (depois)\")\nprint(\"git push\")\nprint(\"\")\nprint(\"# Trazer mudanças do remoto\")\nprint(\"git pull\")",
        "test_code": "assert \"git remote add origin\" in output and \"git push\" in output and \"git pull\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-git-internals-dir-1",
        "lesson_id": "01-internals-theory",
        "title": "Explorando o Diretório .git",
        "description": "Demonstre conhecimento sobre a estrutura do diretório .git e seus componentes principais.",
        "difficulty": "Médio",
        "order": 9,
        "instructions": "Imprima uma descrição dos principais componentes do diretório .git: HEAD, config, objects/ e refs/.",
        "initial_code": "# Descreva os componentes principais do diretório .git\n# print(\"HEAD: ...\")\n# print(\"config: ...\")\n# print(\"objects/: ...\")\n# print(\"refs/: ...\")",
        "solution_code": "print(\"Componentes principais do diretório .git:\")\nprint(\"\")\nprint(\"HEAD: Ponteiro para o branch atual\")\nprint(\"config: Configurações locais do repositório\")\nprint(\"objects/: Banco de dados de objetos (blobs, trees, commits, tags)\")\nprint(\"refs/: Ponteiros para commits (branches, tags, remotes)\")",
        "test_code": "assert \"HEAD\" in output and \"config\" in output and \"objects\" in output and \"refs\" in output and (\"ponteiro\" in output.lower() or \"pointer\" in output.lower())",
        "level": "avançado"
    },
    {
        "id": "ex-git-internals-objects-1",
        "lesson_id": "01-internals-theory",
        "title": "Tipos de Objetos do Git",
        "description": "Explique os quatro tipos principais de objetos no Git e suas funções.",
        "difficulty": "Médio",
        "order": 10,
        "instructions": "Imprima uma descrição de cada tipo de objeto: Blob, Tree, Commit e Tag.",
        "initial_code": "# Descreva os quatro tipos de objetos do Git\n# print(\"Blob: ...\")\n# print(\"Tree: ...\")\n# print(\"Commit: ...\")\n# print(\"Tag: ...\")",
        "solution_code": "print(\"Tipos de Objetos do Git:\")\nprint(\"\")\nprint(\"Blob: Armazena o conteúdo de um arquivo (sem nome)\")\nprint(\"Tree: Representa diretórios, mapeia nomes para blobs e outras trees\")\nprint(\"Commit: Une tudo, aponta para uma tree raiz e commit(s) pai(s)\")\nprint(\"Tag: Rótulo fixo para um commit específico (usado para releases)\")",
        "test_code": "assert \"Blob\" in output and \"Tree\" in output and \"Commit\" in output and \"Tag\" in output and (\"conteúdo\" in output.lower() or \"content\" in output.lower())",
        "level": "avançado"
    },
    {
        "id": "ex-git-internals-hash-1",
        "lesson_id": "01-internals-lab-objects",
        "title": "Usando git hash-object",
        "description": "Demonstre o uso do comando git hash-object para criar objetos no banco de dados do Git.",
        "difficulty": "Difícil",
        "order": 11,
        "instructions": "Imprima o comando para criar um blob com o conteúdo 'Hello Git' e gravá-lo no banco de dados.",
        "initial_code": "# Imprima o comando para criar um blob\n# print(\"echo 'Hello Git' | git hash-object -w --stdin\")",
        "solution_code": "print(\"# Criar um blob e gravar no banco de dados\")\nprint(\"echo 'Hello Git' | git hash-object -w --stdin\")\nprint(\"\")\nprint(\"# O comando retorna o hash SHA-1 do objeto criado\")\nprint(\"# -w: grava o objeto no banco de dados\")\nprint(\"# --stdin: lê o conteúdo da entrada padrão\")",
        "test_code": "assert \"git hash-object\" in output and \"-w\" in output and \"--stdin\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-git-internals-catfile-1",
        "lesson_id": "01-internals-lab-objects",
        "title": "Usando git cat-file",
        "description": "Demonstre o uso do comando git cat-file para inspecionar objetos do Git.",
        "difficulty": "Médio",
        "order": 12,
        "instructions": "Imprima os comandos para: 1) Verificar o tipo de um objeto, 2) Ver o conteúdo de um objeto.",
        "initial_code": "# Imprima os comandos git cat-file\n# print(\"git cat-file -t [HASH]\")\n# print(\"git cat-file -p [HASH]\")",
        "solution_code": "print(\"# Verificar o tipo de um objeto\")\nprint(\"git cat-file -t abc123\")\nprint(\"# Retorna: blob, tree, commit ou tag\")\nprint(\"\")\nprint(\"# Ver o conteúdo de um objeto\")\nprint(\"git cat-file -p abc123\")\nprint(\"# -p: pretty-print (exibe de forma legível)\")",
        "test_code": "assert \"git cat-file\" in output and \"-t\" in output and \"-p\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-git-history-amend-1",
        "lesson_id": "02-advanced-history-theory-rebase",
        "title": "Usando git commit --amend",
        "description": "Demonstre como corrigir o último commit usando --amend.",
        "difficulty": "Fácil",
        "order": 13,
        "instructions": "Imprima os comandos para: 1) Adicionar um arquivo esquecido ao último commit, 2) Alterar a mensagem do último commit.",
        "initial_code": "# Imprima os comandos para emendar o último commit\n# print(\"git add arquivo_esquecido.txt\")\n# print(\"git commit --amend\")",
        "solution_code": "print(\"# Adicionar arquivo esquecido ao último commit\")\nprint(\"git add arquivo_esquecido.txt\")\nprint(\"git commit --amend --no-edit\")\nprint(\"\")\nprint(\"# Alterar apenas a mensagem do último commit\")\nprint(\"git commit --amend -m 'Nova mensagem corrigida'\")\nprint(\"\")\nprint(\"# AVISO: Não use --amend em commits já enviados (pushed)!\")",
        "test_code": "assert \"git commit --amend\" in output and (\"--no-edit\" in output or \"-m\" in output)",
        "level": "avançado"
    },
    {
        "id": "ex-git-history-rebase-1",
        "lesson_id": "02-advanced-history-theory-rebase",
        "title": "Rebase Interativo - Squash",
        "description": "Demonstre como usar git rebase -i para combinar (squash) múltiplos commits.",
        "difficulty": "Difícil",
        "order": 14,
        "instructions": "Imprima o comando para iniciar um rebase interativo dos últimos 3 commits e explique a opção 'squash'.",
        "initial_code": "# Imprima o comando de rebase interativo\n# print(\"git rebase -i HEAD~3\")\n# print(\"squash: ...\")",
        "solution_code": "print(\"# Iniciar rebase interativo dos últimos 3 commits\")\nprint(\"git rebase -i HEAD~3\")\nprint(\"\")\nprint(\"# No editor, você verá:\")\nprint(\"pick abc123 Commit 1\")\nprint(\"pick def456 Commit 2\")\nprint(\"pick ghi789 Commit 3\")\nprint(\"\")\nprint(\"# Para combinar commits, mude 'pick' para 'squash' (ou 's'):\")\nprint(\"pick abc123 Commit 1\")\nprint(\"squash def456 Commit 2\")\nprint(\"squash ghi789 Commit 3\")\nprint(\"\")\nprint(\"# Isso combinará os 3 commits em um único commit\")",
        "test_code": "assert \"git rebase -i\" in output and \"HEAD~3\" in output and \"squash\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-git-history-rebase-2",
        "lesson_id": "02-advanced-history-lab-interactive-rebase",
        "title": "Rebase Interativo - Reword",
        "description": "Demonstre como usar git rebase -i para alterar mensagens de commits antigos.",
        "difficulty": "Médio",
        "order": 15,
        "instructions": "Explique como usar a opção 'reword' no rebase interativo para alterar a mensagem de um commit.",
        "initial_code": "# Explique o uso de 'reword' no rebase interativo\n# print(\"reword: ...\")",
        "solution_code": "print(\"# Opção 'reword' no rebase interativo\")\nprint(\"\")\nprint(\"git rebase -i HEAD~5\")\nprint(\"\")\nprint(\"# No editor, mude 'pick' para 'reword' (ou 'r'):\")\nprint(\"pick abc123 Commit antigo\")\nprint(\"reword def456 Commit com mensagem ruim\")\nprint(\"pick ghi789 Outro commit\")\nprint(\"\")\nprint(\"# O Git pausará no commit marcado e abrirá o editor\")\nprint(\"# para você alterar a mensagem\")\nprint(\"# Diferente de 'squash', não combina commits\")",
        "test_code": "assert \"reword\" in output and \"git rebase -i\" in output and (\"mensagem\" in output.lower() or \"message\" in output.lower())",
        "level": "avançado"
    },
    {
        "id": "ex-git-history-reflog-1",
        "lesson_id": "02-advanced-history-theory-rebase",
        "title": "Recuperando com git reflog",
        "description": "Demonstre como usar git reflog para recuperar commits 'perdidos'.",
        "difficulty": "Médio",
        "order": 16,
        "instructions": "Imprima os comandos para: 1) Ver o reflog, 2) Recuperar um estado anterior usando HEAD@{n}.",
        "initial_code": "# Imprima os comandos para usar o reflog\n# print(\"git reflog\")\n# print(\"git reset --hard HEAD@{2}\")",
        "solution_code": "print(\"# Ver o histórico de onde HEAD esteve\")\nprint(\"git reflog\")\nprint(\"\")\nprint(\"# Exemplo de saída:\")\nprint(\"# abc123 HEAD@{0}: commit: Novo commit\")\nprint(\"# def456 HEAD@{1}: rebase: Rebase finalizado\")\nprint(\"# ghi789 HEAD@{2}: commit: Commit antes do rebase\")\nprint(\"\")\nprint(\"# Recuperar estado anterior (antes do rebase)\")\nprint(\"git reset --hard HEAD@{2}\")\nprint(\"\")\nprint(\"# O reflog é sua rede de segurança!\")",
        "test_code": "assert \"git reflog\" in output and \"HEAD@{\" in output and \"git reset --hard\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-git-workflow-gitflow-1",
        "lesson_id": "03-workflows-theory-gitflow",
        "title": "Entendendo Git Flow",
        "description": "Demonstre conhecimento sobre a estrutura de branches do Git Flow.",
        "difficulty": "Médio",
        "order": 17,
        "instructions": "Imprima uma descrição dos principais branches do Git Flow: master, develop, feature/*, release/* e hotfix/*.",
        "initial_code": "# Descreva os branches do Git Flow\n# print(\"master: ...\")\n# print(\"develop: ...\")\n# print(\"feature/*: ...\")\n# print(\"release/*: ...\")\n# print(\"hotfix/*: ...\")",
        "solution_code": "print(\"Estrutura de Branches do Git Flow:\")\nprint(\"\")\nprint(\"master: Histórico de produção, apenas releases oficiais\")\nprint(\"develop: Branch de integração principal\")\nprint(\"feature/*: Novas funcionalidades, nascem e morrem na develop\")\nprint(\"release/*: Preparação para nova versão, apenas bugfixes\")\nprint(\"hotfix/*: Correção urgente em produção, nasce da master\")",
        "test_code": "assert \"master\" in output and \"develop\" in output and \"feature\" in output and \"release\" in output and \"hotfix\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-git-workflow-gitflow-2",
        "lesson_id": "03-workflows-lab-workflow-sim",
        "title": "Simulando Feature Branch no Git Flow",
        "description": "Demonstre o ciclo completo de uma feature no Git Flow.",
        "difficulty": "Difícil",
        "order": 18,
        "instructions": "Imprima a sequência de comandos para: 1) Criar feature branch da develop, 2) Trabalhar na feature, 3) Fazer merge de volta na develop.",
        "initial_code": "# Simule o ciclo de uma feature no Git Flow\n# print(\"git checkout develop\")\n# print(\"git checkout -b feature/nova-funcionalidade\")\n# ...",
        "solution_code": "print(\"# 1. Criar feature branch a partir da develop\")\nprint(\"git checkout develop\")\nprint(\"git checkout -b feature/login-page\")\nprint(\"\")\nprint(\"# 2. Trabalhar na feature\")\nprint(\"# ... fazer commits ...\")\nprint(\"git add login.html\")\nprint(\"git commit -m 'feat: adiciona página de login'\")\nprint(\"\")\nprint(\"# 3. Finalizar feature (merge na develop)\")\nprint(\"git checkout develop\")\nprint(\"git merge --no-ff feature/login-page\")\nprint(\"\")\nprint(\"# 4. Deletar o branch de feature\")\nprint(\"git branch -d feature/login-page\")",
        "test_code": "assert \"git checkout develop\" in output and \"git checkout -b feature/\" in output and \"git merge --no-ff\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-git-workflow-github-1",
        "lesson_id": "03-workflows-theory-gitflow",
        "title": "GitHub Flow",
        "description": "Explique o fluxo de trabalho do GitHub Flow.",
        "difficulty": "Médio",
        "order": 19,
        "instructions": "Imprima os passos principais do GitHub Flow.",
        "initial_code": "# Descreva os passos do GitHub Flow\n# print(\"1. ...\")\n# print(\"2. ...\")",
        "solution_code": "print(\"GitHub Flow - Passos:\")\nprint(\"\")\nprint(\"1. Branch main é sempre deployável\")\nprint(\"2. Criar branch descritivo a partir da main\")\nprint(\"   git checkout -b new-oauth\")\nprint(\"3. Fazer commits no branch\")\nprint(\"4. Abrir Pull Request para discussão e review\")\nprint(\"5. Após aprovação, fazer merge na main\")\nprint(\"6. Deploy imediato após merge\")\nprint(\"\")\nprint(\"Mais simples que Git Flow, ideal para web apps\")",
        "test_code": "assert \"main\" in output and \"Pull Request\" in output and \"deploy\" in output.lower()",
        "level": "avançado"
    },
    {
        "id": "ex-git-tools-hooks-1",
        "lesson_id": "04-tools-theory-hooks",
        "title": "Criando um Git Hook pre-commit",
        "description": "Demonstre como criar um hook pre-commit para executar testes antes de cada commit.",
        "difficulty": "Difícil",
        "order": 20,
        "instructions": "Imprima o conteúdo de um script pre-commit que executa testes Python e impede o commit se os testes falharem.",
        "initial_code": "# Crie um script pre-commit\n# print(\"#!/bin/bash\")\n# print(\"pytest\")\n# ...",
        "solution_code": "print(\"# Arquivo: .git/hooks/pre-commit\")\nprint(\"# Tornar executável: chmod +x .git/hooks/pre-commit\")\nprint(\"\")\nprint(\"#!/bin/bash\")\nprint(\"\")\nprint(\"echo 'Executando testes antes do commit...'\")\nprint(\"\")\nprint(\"# Executar testes\")\nprint(\"pytest\")\nprint(\"\")\nprint(\"# Capturar código de saída\")\nprint(\"if [ $? -ne 0 ]; then\")\nprint(\"    echo 'ERRO: Testes falharam! Commit abortado.'\")\nprint(\"    exit 1\")\nprint(\"fi\")\nprint(\"\")\nprint(\"echo 'Testes passaram! Prosseguindo com commit.'\")\nprint(\"exit 0\")",
        "test_code": "assert \"#!/bin/bash\" in output and \"pre-commit\" in output and \"pytest\" in output and \"exit\" in output",
        "level": "avançado"
    },
    {
        "id": "ex-git-tools-hooks-2",
        "lesson_id": "04-tools-theory-hooks",
        "title": "Tipos de Git Hooks",
        "description": "Demonstre conhecimento sobre os diferentes tipos de Git Hooks.",
        "difficulty": "Médio",
        "order": 21,
        "instructions": "Imprima uma descrição dos hooks: pre-commit, commit-msg e pre-push.",
        "initial_code": "# Descreva os tipos de hooks\n# print(\"pre-commit: ...\")\n# print(\"commit-msg: ...\")\n# print(\"pre-push: ...\")",
        "solution_code": "print(\"Tipos Comuns de Git Hooks:\")\nprint(\"\")\nprint(\"pre-commit:\")\nprint(\"  - Executa antes do commit ser criado\")\nprint(\"  - Usado para linters, formatadores, testes rápidos\")\nprint(\"  - Pode abortar o commit se falhar\")\nprint(\"\")\nprint(\"commit-msg:\")\nprint(\"  - Valida a mensagem do commit\")\nprint(\"  - Pode exigir padrão como 'feat: ...' ou 'fix: ...'\")\nprint(\"  - Recebe o arquivo com a mensagem como argumento\")\nprint(\"\")\nprint(\"pre-push:\")\nprint(\"  - Executa antes do push\")\nprint(\"  - Usado para rodar suíte completa de testes\")\nprint(\"  - Pode impedir push se testes falharem\")",
        "test_code": "assert \"pre-commit\" in output and \"commit-msg\" in output and \"pre-push\" in output and (\"lint\" in output.lower() or \"test\" in output.lower())",
        "level": "avançado"
    },
    {
        "id": "ex-git-tools-bisect-1",
        "lesson_id": "04-tools-theory-hooks",
        "title": "Entendendo git bisect",
        "description": "Explique como o git bisect funciona para encontrar bugs.",
        "difficulty": "Médio",
        "order": 22,
        "instructions": "Imprima uma explicação de como o git bisect usa busca binária para encontrar o commit que introduziu um bug.",
        "initial_code": "# Explique o git bisect\n# print(\"git bisect usa busca binária...\")",
        "solution_code": "print(\"Git Bisect - Busca Binária de Bugs\")\nprint(\"\")\nprint(\"Como funciona:\")\nprint(\"1. Você marca o commit atual como 'bad' (com bug)\")\nprint(\"2. Você marca um commit antigo como 'good' (sem bug)\")\nprint(\"3. Git faz checkout no meio do caminho\")\nprint(\"4. Você testa e diz se está 'good' ou 'bad'\")\nprint(\"5. Git repete até isolar o commit exato\")\nprint(\"\")\nprint(\"Exemplo:\")\nprint(\"git bisect start\")\nprint(\"git bisect bad          # Commit atual está ruim\")\nprint(\"git bisect good abc123  # Commit abc123 estava bom\")\nprint(\"# ... testar e marcar good/bad até encontrar ...\")\nprint(\"git bisect reset        # Sair do modo bisect\")",
        "test_code": "assert \"git bisect\" in output and \"good\" in output and \"bad\" in output and (\"binária\" in output.lower() or \"binary\" in output.lower())",
        "level": "avançado"
    },
    {
        "id": "ex-git-tools-bisect-2",
        "lesson_id": "04-tools-lab-bisect",
        "title": "Simulando git bisect",
        "description": "Demonstre a sequência de comandos para usar git bisect na prática.",
        "difficulty": "Difícil",
        "order": 23,
        "instructions": "Imprima a sequência completa de comandos para usar git bisect, incluindo como marcar commits como good/bad.",
        "initial_code": "# Simule o uso do git bisect\n# print(\"git bisect start\")\n# ...",
        "solution_code": "print(\"# Cenário: Bug apareceu entre commit inicial e HEAD\")\nprint(\"\")\nprint(\"# 1. Iniciar bisect\")\nprint(\"git bisect start\")\nprint(\"\")\nprint(\"# 2. Marcar HEAD como ruim\")\nprint(\"git bisect bad\")\nprint(\"\")\nprint(\"# 3. Marcar commit antigo como bom\")\nprint(\"git bisect good abc123\")\nprint(\"\")\nprint(\"# 4. Git faz checkout no meio - testar o código\")\nprint(\"# Se o bug existe:\")\nprint(\"git bisect bad\")\nprint(\"# Se o bug NÃO existe:\")\nprint(\"git bisect good\")\nprint(\"\")\nprint(\"# 5. Repetir até Git encontrar o commit culpado\")\nprint(\"# Git dirá: 'abc456 is the first bad commit'\")\nprint(\"\")\nprint(\"# 6. Sair do modo bisect\")\nprint(\"git bisect reset\")",
        "test_code": "assert \"git bisect start\" in output and \"git bisect bad\" in output and \"git bisect good\" in output and \"git bisect reset\" in output",
        "level": "avançado"
    }
]