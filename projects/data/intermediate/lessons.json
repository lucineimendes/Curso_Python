[
    {
        "id": "poo-intro-conceitos",
        "course_id": "python-intermediario",
        "title": "POO (Parte 1): Introdução e Conceitos Fundamentais",
        "order": 20,
        "description": "Entenda o que é Programação Orientada a Objetos (POO), seus benefícios e os conceitos essenciais de classes, objetos, atributos, métodos e encapsulamento.",
        "learning_objectives": [
            "Definir Programação Orientada a Objetos (POO) e seus princípios básicos.",
            "Identificar as vantagens de usar POO no desenvolvimento de software.",
            "Explicar o conceito de Classe como um molde ou projeto.",
            "Explicar o conceito de Objeto como uma instância de uma classe.",
            "Diferenciar Atributos (dados) de Métodos (comportamentos) de um objeto.",
            "Compreender a ideia de Encapsulamento."
        ],
        "key_concepts": [
            "Programação Orientada a Objetos (POO)",
            "Classe",
            "Objeto (Instância)",
            "Atributo",
            "Método",
            "Encapsulamento",
            "Abstração (mencionado)",
            "Herança (mencionado)",
            "Polimorfismo (mencionado)"
        ],
        "content": "<h2>POO: Introdução e Conceitos Fundamentais</h2>\n\n<p>A <strong>Programação Orientada a Objetos (POO)</strong> é um paradigma de programação que organiza o código em torno de \"objetos\". Em vez de focar em lógica e funções separadas, a POO modela o software como uma coleção de objetos que interagem entre si. Cada objeto é uma instância de uma <strong>classe</strong>, que atua como um molde ou projeto para criar esses objetos.</p>\n\n<h3>Por que Usar POO?</h3>\n<p>A POO oferece diversas vantagens no desenvolvimento de software:</p>\n<ul>\n  <li><strong>Modularidade:</strong> O código é organizado em classes, tornandoo mais fácil de entender, manter e depurar.</li>\n  <li><strong>Reutilização de Código:</strong> Classes podem ser reutilizadas em diferentes partes de um projeto ou em outros projetos (através da herança, por exemplo).</li>\n  <li><strong>Abstração:</strong> Permite modelar entidades do mundo real de forma mais intuitiva, focando nos aspectos relevantes e escondendo detalhes complexos de implementação.</li>\n  <li><strong>Encapsulamento:</strong> Agrupa dados (atributos) e os comportamentos (métodos) que operam nesses dados dentro de um objeto, protegendo os dados de acesso externo indevido.</li>\n  <li><strong>Flexibilidade e Escalabilidade:</strong> Facilita a modificação e extensão de sistemas existentes.</li>\n</ul>\n\n<h3>Conceitos Chave da POO</h3>\n\n<h4>1. Classe</h4>\n<p>Uma <strong>classe</strong> é um projeto, um molde ou um modelo para criar objetos. Ela define um conjunto de características (atributos) e comportamentos (métodos) que todos os objetos criados a partir dela terão. Pense em uma classe como a planta de uma casa: ela descreve como a casa será, mas não é a casa em si.</p>\n<p>Exemplo: Classe <code>Carro</code>. Define que todo carro terá atributos como <code>cor</code>, <code>marca</code>, <code>modelo</code> e métodos como <code>acelerar()</code>, <code>frear()</code>.</p>\n\n<h4>2. Objeto (ou Instância)</h4>\n<p>Um <strong>objeto</strong> é uma instância específica de uma classe. É a concretização do molde definido pela classe. Se a classe <code>Carro</code> é a planta, um objeto seria uma casa específica construída a partir dessa planta (ex: \"meu carro vermelho da marca X, modelo Y\"). Cada objeto tem seus próprios valores para os atributos definidos na classe.</p>\n<p>Exemplo: <code>meu_carro = Carro()</code>. <code>meu_carro</code> é um objeto da classe <code>Carro</code>.</p>\n\n<h4>3. Atributo</h4>\n<p><strong>Atributos</strong> são as características ou dados que um objeto possui. São como variáveis associadas a um objeto. Na classe <code>Carro</code>, <code>cor</code>, <code>marca</code> e <code>velocidade_atual</code> seriam atributos.</p>\n<p>Exemplo: <code>meu_carro.cor = \"azul\"</code>.</p>\n\n<h4>4. Método</h4>\n<p><strong>Métodos</strong> são as ações ou comportamentos que um objeto pode realizar. São como funções associadas a um objeto, que geralmente operam sobre os atributos desse objeto. Na classe <code>Carro</code>, <code>acelerar()</code>, <code>frear()</code> e <code>ligar_motor()</code> seriam métodos.</p>\n<p>Exemplo: <code>meu_carro.acelerar(10)</code>.</p>\n\n<h4>5. Encapsulamento</h4>\n<p>O <strong>encapsulamento</strong> é o princípio de agrupar os dados (atributos) e os métodos que os manipulam dentro de uma unidade (o objeto). Ele também envolve restringir o acesso direto aos dados internos do objeto, geralmente expondo apenas uma interface controlada (métodos públicos) para interagir com o objeto. Isso protege os dados de modificações acidentais e ajuda a manter a integridade do objeto.</p>\n\n<h3>Outros Pilares da POO (que veremos em breve)</h3>\n<ul>\n  <li><strong>Herança:</strong> Permite que uma classe (subclasse) herde atributos e métodos de outra classe (superclasse), promovendo a reutilização de código.</li>\n  <li><strong>Polimorfismo:</strong> (Do grego, \"muitas formas\") Permite que objetos de diferentes classes respondam à mesma mensagem (chamada de método) de maneiras específicas para cada classe.</li>\n</ul>\n\n<p>A POO é um paradigma poderoso que, quando bem aplicado, leva a um código mais organizado, robusto e fácil de manter.</p>",
        "examples": [
            {
                "title": "Analogia: Classe Biscoito e Objetos Biscoitos",
                "code": null,
                "explanation": "<p>Imagine uma <strong>Classe</strong> chamada <code>FormaDeBiscoito</code>. Ela define o formato (ex: estrela), o tamanho e talvez a receita base.</p>\n<p>Cada <strong>Objeto</strong> seria um biscoito individual que você corta usando essa forma. Todos os biscoitos (objetos) terão o mesmo formato (definido pela classe), mas cada um pode ter seus próprios <strong>Atributos</strong> (ex: um pode ter cobertura de chocolate, outro granulado; são biscoitos diferentes, mas da mesma 'classe' de forma).</p>\n<p>Um <strong>Método</strong> poderia ser <code>assar()</code> ou <code>decorar()</code>, ações que podem ser aplicadas aos biscoitos.</p>"
            }
        ],
        "summary": "<p>A Programação Orientada a Objetos (POO) organiza o código em torno de classes e objetos. Classes são moldes que definem atributos (dados) e métodos (comportamentos), enquanto objetos são instâncias dessas classes. O encapsulamento protege os dados do objeto. POO promove modularidade, reutilização e uma modelagem mais intuitiva de problemas complexos.</p>",
        "estimated_time_minutes": 30
    },
    {
        "id": "poo-classes-objetos-python",
        "course_id": "python-intermediario",
        "title": "POO (Parte 2): Definindo Classes e Criando Objetos",
        "order": 21,
        "description": "Aprenda a sintaxe para definir classes em Python usando a palavrachave 'class', criar construtores com '__init__', entender o parâmetro 'self', e instanciar objetos.",
        "learning_objectives": [
            "Definir uma classe em Python usando a sintaxe `class NomeDaClasse:`.",
            "Implementar o método construtor `__init__` para inicializar os atributos de um objeto.",
            "Entender o papel do parâmetro `self` como referência à instância do objeto.",
            "Criar (instanciar) objetos a partir de uma classe.",
            "Acessar atributos de um objeto usando a notação de ponto.",
            "Chamar métodos de um objeto usando a notação de ponto."
        ],
        "key_concepts": [
            "Palavrachave `class`",
            "Método Construtor `__init__`",
            "Parâmetro `self`",
            "Atributos de Instância",
            "Métodos de Instância",
            "Instanciação de Objetos",
            "Notação de Ponto (Acesso a Atributos/Métodos)"
        ],
        "content": "<h2>Definindo Classes e Criando Objetos em Python</h2>\n\n<p>Agora que entendemos os conceitos básicos da POO, vamos ver como aplicálos em Python.</p>\n\n<h3>Definindo uma Classe</h3>\n<p>Em Python, você define uma classe usando a palavrachave <code>class</code>, seguida pelo nome da classe (por convenção, iniciado com letra maiúscula  CamelCase) e dois pontos. O corpo da classe é indentado e contém as definições de atributos e métodos.</p>\n\n<pre><code class=\"languagepython\">class Cachorro:\n    # Atributo de classe (compartilhado por todas as instâncias, opcional)\n    especie = \"Canis familiaris\"\n\n    # Método construtor (inicializador)\n    def __init__(self, nome_param, raca_param, idade_param):\n        # Atributos de instância (específicos para cada objeto)\n        self.nome = nome_param  # 'self.nome' é um atributo do objeto\n        self.raca = raca_param\n        self.idade = idade_param\n        self.energia = 100 # Um atributo com valor inicial fixo\n\n    # Método de instância\n    def latir(self):\n        if self.energia >= 10:\n            self.energia = 10\n            return f\"{self.nome} diz: Au au! (Energia: {self.energia})\"\n        else:\n            return f\"{self.nome} está muito cansado para latir. (Energia: {self.energia})\"\n\n    # Outro método de instância\n    def descrever(self):\n        return f\"{self.nome} é um {self.raca} de {self.idade} anos.\"\n\n    def brincar(self, tempo_minutos):\n        gasto_energia = tempo_minutos * 2\n        if self.energia >= gasto_energia:\n            self.energia = gasto_energia\n            print(f\"{self.nome} brincou por {tempo_minutos} minutos. Energia atual: {self.energia}\")\n        else:\n            print(f\"{self.nome} não tem energia suficiente para brincar tanto tempo.\")</code></pre>\n\n<h4>O Método Construtor: `__init__`</h4>\n<p>O método <code>__init__</code> (com dois underscores antes e depois) é um método especial chamado <strong>construtor</strong> ou <strong>inicializador</strong>. Ele é executado automaticamente sempre que um novo objeto da classe é criado (instanciado).</p>\n<p>Sua principal função é inicializar os atributos do objeto. O primeiro parâmetro de <code>__init__</code> (e de qualquer método de instância) é, por convenção, chamado de <code>self</code>.</p>\n\n<h4>O Parâmetro `self`</h4>\n<p><code>self</code> é uma referência à própria instância do objeto que está sendo criado ou cujo método está sendo chamado. Através de <code>self</code>, você pode acessar e modificar os atributos e chamar outros métodos do objeto.</p>\n<p>Quando você define um atributo como <code>self.nome = nome_param</code>, você está criando um atributo chamado <code>nome</code> que pertence à instância específica (<code>self</code>) do objeto.</p>\n\n<h3>Criando Objetos (Instanciando uma Classe)</h3>\n<p>Para criar um objeto (uma instância) de uma classe, você chama a classe como se fosse uma função, passando os argumentos esperados pelo método <code>__init__</code> (exceto o <code>self</code>, que é passado automaticamente pelo Python).</p>\n\n<pre><code class=\"languagepython\"># Criando (instanciando) objetos da classe Cachorro\nrex = Cachorro(\"Rex\", \"Labrador\", 3)\nbolinha = Cachorro(\"Bolinha\", \"Poodle\", 5)\n\n# 'rex' e 'bolinha' são agora objetos (instâncias) da classe Cachorro.\n# Cada um tem seus próprios atributos 'nome', 'raca', 'idade' e 'energia'.</code></pre>\n\n<h3>Acessando Atributos e Chamando Métodos</h3>\n<p>Você acessa os atributos e chama os métodos de um objeto usando a <strong>notação de ponto</strong> (<code>objeto.atributo</code> ou <code>objeto.metodo()</code>).</p>\n\n<pre><code class=\"languagepython\"># Acessando atributos de 'rex'\nprint(f\"Nome do primeiro cachorro: {rex.nome}\")       # Saída: Rex\nprint(f\"Raça do segundo cachorro: {bolinha.raca}\")    # Saída: Poodle\nprint(f\"Energia inicial do Rex: {rex.energia}\")      # Saída: 100\n\n# Chamando métodos de 'rex'\nprint(rex.descrever())  # Saída: Rex é um Labrador de 3 anos.\nprint(rex.latir())      # Saída: Rex diz: Au au! (Energia: 90)\n\n# Chamando métodos de 'bolinha'\nprint(bolinha.latir())  # Saída: Bolinha diz: Au au! (Energia: 90)\nbolinha.brincar(30)\nprint(bolinha.latir())  # Saída: Bolinha diz: Au au! (Energia: 20)\nbolinha.brincar(15)     # Saída: Bolinha não tem energia suficiente...\n\n# Acessando atributo de classe (pode ser pela classe ou pela instância)\nprint(f\"Espécie de todos os cachorros: {Cachorro.especie}\") # Saída: Canis familiaris\nprint(f\"Espécie do Rex: {rex.especie}\")                     # Saída: Canis familiaris</code></pre>\n\n<p>Cada objeto mantém seu próprio estado (valores dos atributos). Modificar um atributo de <code>rex</code> não afeta <code>bolinha</code>.</p>",
        "examples": [
            {
                "title": "Classe Livro",
                "code": "class Livro:\n    def __init__(self, titulo, autor, paginas):\n        self.titulo = titulo\n        self.autor = autor\n        self.paginas = paginas\n        self.pagina_atual = 1\n\n    def ler_pagina(self):\n        if self.pagina_atual <= self.paginas:\n            print(f\"Lendo página {self.pagina_atual} de '{self.titulo}'.\")\n            self.pagina_atual = 1\n        else:\n            print(f\"Você já terminou de ler '{self.titulo}'.\")\n\n    def info(self):\n        return f\"'{self.titulo}' por {self.autor}, {self.paginas} páginas.\"\n\n# Criando e usando objetos Livro\nlivro1 = Livro(\"O Senhor dos Anéis\", \"J.R.R. Tolkien\", 1200)\nprint(livro1.info())\nlivro1.ler_pagina()\nlivro1.ler_pagina()",
                "explanation": "<p>Define uma classe <code>Livro</code> com atributos como título, autor, páginas e página atual. Possui métodos para ler uma página e obter informações do livro. Em seguida, cria um objeto <code>livro1</code> e interage com ele.</p>"
            }
        ],
        "summary": "<p>Classes são definidas com a palavrachave <code>class</code>. O método <code>__init__</code> é o construtor usado para inicializar os atributos da instância, referenciados por <code>self</code>. Objetos são criados chamando a classe como uma função, e seus atributos e métodos são acessados usando a notação de ponto.</p>",
        "estimated_time_minutes": 35
    },
    {
        "id": "poo-heranca-python",
        "course_id": "python-intermediario",
        "title": "POO (Parte 3): Herança",
        "order": 22,
        "description": "Aprenda sobre herança em Python, como criar subclasses que herdam de superclasses, utilizar o método super() e sobrescrever métodos.",
        "learning_objectives": [
            "Entender o conceito de herança e sua importância para a reutilização de código.",
            "Definir uma subclasse que herda de uma superclasse.",
            "Utilizar a função `super()` para chamar métodos da superclasse, especialmente o construtor.",
            "Sobrescrever (override) métodos da superclasse na subclasse para fornecer implementações específicas.",
            "Adicionar novos atributos e métodos específicos à subclasse."
        ],
        "key_concepts": [
            "Herança",
            "Superclasse (Classe Pai, Classe Base)",
            "Subclasse (Classe Filha, Classe Derivada)",
            "Reutilização de Código",
            "Relação \"é um(a)\"",
            "Função `super()`",
            "Sobrescrita de Métodos (Method Overriding)"
        ],
        "content": "<h2>Herança: Reutilizando e Estendendo Classes</h2>\n\n<p>A <strong>herança</strong> é um dos pilares fundamentais da Programação Orientada a Objetos. Ela permite que você crie uma nova classe (chamada <strong>subclasse</strong>, classe filha ou classe derivada) que herda atributos e métodos de uma classe existente (chamada <strong>superclasse</strong>, classe pai ou classe base).</p>\n\n<p>A principal vantagem da herança é a <strong>reutilização de código</strong>. Em vez de reescrever funcionalidades comuns, você pode definilas uma vez na superclasse e fazer com que as subclasses as herdem. A herança também estabelece uma relação do tipo \"é um(a)\" (por exemplo, um <code>Cachorro</code> <em>é um</em> <code>Animal</code>).</p>\n\n<h3>Definindo uma Subclasse</h3>\n<p>Para definir uma subclasse, você especifica a superclasse entre parênteses após o nome da subclasse:</p>\n\n<pre><code class=\"languagepython\">class Animal:  # Superclasse\n    def __init__(self, nome):\n        self.nome = nome\n        print(\"Animal criado.\")\n\n    def comer(self):\n        print(f\"{self.nome} está comendo.\")\n\n    def fazer_som(self):\n        print(\"O animal faz um som genérico.\")\n\nclass Cachorro(Animal):  # Subclasse Cachorro herda de Animal\n    def __init__(self, nome, raca):\n        # Chama o construtor da superclasse (Animal)\n        super().__init__(nome)\n        self.raca = raca  # Atributo específico de Cachorro\n        print(\"Cachorro criado.\")\n\n    # Sobrescrevendo o método fazer_som da superclasse\n    def fazer_som(self):\n        print(f\"{self.nome} late: Au au!\")\n\n    # Método específico de Cachorro\n    def buscar_bola(self):\n        print(f\"{self.nome} está buscando a bola.\")\n\nclass Gato(Animal): # Outra subclasse de Animal\n    def __init__(self, nome, cor_pelo):\n        super().__init__(nome)\n        self.cor_pelo = cor_pelo\n        print(\"Gato criado.\")\n\n    def fazer_som(self):\n        print(f\"{self.nome} mia: Miau!\")\n\n    def arranhar_sofa(self):\n        print(f\"{self.nome} está arranhando o sofá! ({self.cor_pelo})\")</code></pre>\n\n<h3>A Função `super()`</h3>\n<p>A função <code>super()</code> é usada dentro de uma subclasse para chamar métodos da sua superclasse. É comumente usada no método <code>__init__</code> da subclasse para garantir que o construtor da superclasse seja executado, inicializando os atributos herdados.</p>\n<p>No exemplo acima, <code>super().__init__(nome)</code> na classe <code>Cachorro</code> chama o <code>__init__</code> da classe <code>Animal</code>, passando o <code>nome</code>.</p>\n\n<h3>Sobrescrita de Métodos (Method Overriding)</h3>\n<p>Uma subclasse pode fornecer uma implementação específica para um método que já está definido em sua superclasse. Isso é chamado de <strong>sobrescrita de métodos</strong>. A subclasse \"sobrescreve\" o comportamento do método herdado.</p>\n<p>No exemplo, tanto <code>Cachorro</code> quanto <code>Gato</code> sobrescrevem o método <code>fazer_som()</code> da classe <code>Animal</code> para fornecer sons específicos.</p>\n\n<h3>Adicionando Atributos e Métodos Específicos</h3>\n<p>Além de herdar e sobrescrever, as subclasses podem adicionar seus próprios atributos e métodos que não existem na superclasse. Por exemplo, <code>Cachorro</code> tem o atributo <code>raca</code> e o método <code>buscar_bola()</code>, que são específicos para cachorros.</p>\n\n<h3>Utilizando as Classes</h3>\n<pre><code class=\"languagepython\"># Criando objetos\nmeu_animal = Animal(\"Criatura\")\nrex = Cachorro(\"Rex\", \"Labrador\")\nmimi = Gato(\"Mimi\", \"Siamês\")\n\nprint(\" Ações  \")\nmeu_animal.comer()\nmeu_animal.fazer_som()\n\nprint(\"\\n Rex  \")\nrex.comer()  # Método herdado de Animal\nrex.fazer_som() # Método sobrescrito em Cachorro\nrex.buscar_bola() # Método específico de Cachorro\nprint(f\"Raça do Rex: {rex.raca}\")\n\nprint(\"\\n Mimi  \")\nmimi.comer()\nmimi.fazer_som()\nmimi.arranhar_sofa()\nprint(f\"Cor do pelo da Mimi: {mimi.cor_pelo}\")</code></pre>\n\n<p>A herança é uma ferramenta poderosa para criar hierarquias de classes, reduzir a duplicação de código e construir sistemas mais flexíveis e extensíveis.</p>",
        "examples": [
            {
                "title": "Hierarquia de Veículos",
                "code": "class Veiculo:\n    def __init__(self, marca, ano):\n        self.marca = marca\n        self.ano = ano\n\n    def exibir_info(self):\n        return f\"Marca: {self.marca}, Ano: {self.ano}\"\n\n    def mover(self):\n        print(\"O veículo está se movendo.\")\n\nclass Carro(Veiculo):\n    def __init__(self, marca, ano, modelo, num_portas):\n        super().__init__(marca, ano)\n        self.modelo = modelo\n        self.num_portas = num_portas\n\n    def exibir_info(self): # Sobrescreve\n        info_base = super().exibir_info()\n        return f\"{info_base}, Modelo: {self.modelo}, Portas: {self.num_portas}\"\n\n    def mover(self): # Sobrescreve\n        print(f\"O carro {self.modelo} está acelerando na estrada.\")\n\nclass Bicicleta(Veiculo):\n    def __init__(self, marca, ano, tipo_freio):\n        super().__init__(marca, ano)\n        self.tipo_freio = tipo_freio\n\n    def mover(self): # Sobrescreve\n        print(\"A bicicleta está pedalando na ciclovia.\")\n\n# Testando\nmeu_carro = Carro(\"Toyota\", 2022, \"Corolla\", 4)\nminha_bike = Bicicleta(\"Caloi\", 2023, \"VBrake\")\n\nprint(meu_carro.exibir_info())\nmeu_carro.mover()\n\nprint(minha_bike.exibir_info())\nminha_bike.mover()",
                "explanation": "<p>Este exemplo cria uma superclasse <code>Veiculo</code> e duas subclasses, <code>Carro</code> e <code>Bicicleta</code>. Ambas as subclasses herdam de <code>Veiculo</code>, chamam o construtor da superclasse usando <code>super()</code>, adicionam atributos específicos e sobrescrevem os métodos <code>exibir_info()</code> e <code>mover()</code>.</p>"
            }
        ],
        "summary": "<p>A herança permite que classes (subclasses) herdem características e comportamentos de outras classes (superclasses), promovendo a reutilização de código. A função <code>super()</code> é usada para acessar métodos da superclasse, e as subclasses podem sobrescrever métodos para fornecer implementações especializadas, além de adicionar seus próprios atributos e métodos.</p>",
        "estimated_time_minutes": 40
    },
    {
        "id": "poo-polimorfismo-abstracao-python",
        "course_id": "python-intermediario",
        "title": "POO (Parte 4): Polimorfismo, Abstração e Métodos Especiais",
        "order": 23,
        "description": "Explore conceitos avançados de POO como polimorfismo (Duck Typing), abstração, métodos de classe, métodos estáticos e métodos especiais (mágicos) como __str__.",
        "learning_objectives": [
            "Entender e aplicar o conceito de polimorfismo em Python, incluindo Duck Typing.",
            "Compreender o princípio da abstração e como ele se relaciona com classes abstratas (usando o módulo `abc`).",
            "Diferenciar e utilizar métodos de instância, métodos de classe (`@classmethod`) e métodos estáticos (`@staticmethod`).",
            "Implementar métodos especiais (mágicos), como `__str__` para representação de objetos como strings."
        ],
        "key_concepts": [
            "Polimorfismo",
            "Duck Typing",
            "Abstração",
            "Classes Abstratas (Módulo `abc`)",
            "Métodos de Instância",
            "Métodos de Classe (`@classmethod`)",
            "Métodos Estáticos (`@staticmethod`)",
            "Métodos Especiais (Dunder Methods, Magic Methods)",
            "Método `__str__`"
        ],
        "content": "<h2>POO: Polimorfismo, Abstração e Métodos Especiais</h2>\n\n<p>Continuando nossa jornada pela Programação Orientada a Objetos, vamos explorar conceitos que adicionam ainda mais poder e flexibilidade ao seu código: polimorfismo, abstração e diferentes tipos de métodos dentro de uma classe.</p>\n\n<h3>Polimorfismo e Duck Typing</h3>\n\n<p><strong>Polimorfismo</strong> (do grego, \"muitas formas\") é a capacidade de um objeto ser tratado como um objeto de sua própria classe ou como um objeto de sua superclasse. Mais genericamente, em Python, o polimorfismo é frequentemente associado ao conceito de <strong>Duck Typing</strong>.</p>\n\n<p>A filosofia do Duck Typing é: \"Se anda como um pato e grasna como um pato, então deve ser um pato.\" Isso significa que o tipo de um objeto é menos importante do que os métodos e atributos que ele possui. Se um objeto implementa os métodos esperados por uma determinada operação, ele pode ser usado nessa operação, independentemente de sua classe ou herança.</p>\n\n<pre><code class=\"languagepython\">class Pato:\n    def grasnar(self):\n        print(\"Quack!\")\n    def nadar(self):\n        print(\"Nadando como um pato.\")\n\nclass Pessoa:\n    def grasnar(self):\n        print(\"Eu imito um pato: Quack!\")\n    def nadar(self):\n        print(\"Nadando como uma pessoa.\")\n\ndef interagir_com_pato(obj_pato):\n    obj_pato.grasnar()\n    obj_pato.nadar()\n\nmeu_pato = Pato()\npessoa_imitando = Pessoa()\n\ninteragir_com_pato(meu_pato)       # Funciona\ninteragir_com_pato(pessoa_imitando) # Funciona também, pois Pessoa tem os métodos grasnar() e nadar()</code></pre>\n<p>A função <code>interagir_com_pato</code> não se importa se o objeto é realmente um <code>Pato</code>, apenas se ele pode <code>grasnar()</code> e <code>nadar()</code>.</p>\n\n<h3>Abstração e Classes Abstratas</h3>\n\n<p><strong>Abstração</strong> é o processo de esconder os detalhes complexos de implementação e expor apenas as funcionalidades essenciais de um objeto. Ela ajuda a reduzir a complexidade e a aumentar a clareza.</p>\n\n<p>Uma <strong>Classe Abstrata</strong> (Abstract Base Class  ABC) é uma classe que não pode ser instanciada diretamente. Ela serve como um modelo para subclasses, definindo uma interface comum que as subclasses devem implementar. Em Python, usamos o módulo <code>abc</code> para criar classes e métodos abstratos.</p>\n\n<pre><code class=\"languagepython\">from abc import ABC, abstractmethod\n\nclass FormaGeometrica(ABC):  # Herda de ABC para ser uma classe abstrata\n    @abstractmethod  # Decorador para definir um método abstrato\n    def calcular_area(self):\n        pass\n\n    @abstractmethod\n    def calcular_perimetro(self):\n        pass\n\nclass Quadrado(FormaGeometrica):\n    def __init__(self, lado):\n        self.lado = lado\n\n    def calcular_area(self): # Implementação obrigatória\n        return self.lado ** 2\n\n    def calcular_perimetro(self): # Implementação obrigatória\n        return 4 * self.lado\n\nclass Circulo(FormaGeometrica):\n    def __init__(self, raio):\n        self.raio = raio\n\n    def calcular_area(self):\n        import math\n        return math.pi * (self.raio ** 2)\n\n    def calcular_perimetro(self):\n        import math\n        return 2 * math.pi * self.raio\n\n# forma = FormaGeometrica() # Isso geraria um TypeError, pois não pode instanciar ABC\n\nquad = Quadrado(5)\ncirc = Circulo(3)\n\nprint(f\"Área do Quadrado: {quad.calcular_area()}\")\nprint(f\"Área do Círculo: {circ.calcular_area():.2f}\")</code></pre>\n<p>Se uma subclasse não implementar todos os métodos abstratos da superclasse abstrata, ela também se tornará abstrata e não poderá ser instanciada.</p>\n\n<h3>Tipos de Métodos em uma Classe</h3>\n\n<ol>\n  <li><strong>Métodos de Instância:</strong> São os métodos mais comuns. Eles operam sobre uma instância específica da classe (o objeto). O primeiro parâmetro é sempre <code>self</code>, que se refere à instância.\n    <pre><code class=\"languagepython\">class MinhaClasse:\n    def metodo_instancia(self, valor):\n        self.valor_instancia = valor\n        print(f\"Método de instância chamado com {valor}\")</code></pre>\n  </li>\n  <li><strong>Métodos de Classe (<code>@classmethod</code>):</strong> São métodos vinculados à classe e não a uma instância específica. Eles recebem a própria classe como o primeiro argumento, convencionalmente chamado <code>cls</code>. Podem ser usados para criar métodos fábrica (factory methods) ou para acessar/modificar atributos de classe.\n    <pre><code class=\"languagepython\">class Pizza:\n    pedacos_padrao = 8\n\n    def __init__(self, sabor):\n        self.sabor = sabor\n\n    @classmethod\n    def mudar_pedacos_padrao(cls, novos_pedacos):\n        cls.pedacos_padrao = novos_pedacos\n        print(f\"Padrão de pedaços alterado para {cls.pedacos_padrao}\")\n\n    @classmethod\n    def quatro_queijos(cls):\n        return cls(\"Quatro Queijos\") # Método fábrica\n\nPizza.mudar_pedacos_padrao(6)\nprint(Pizza.pedacos_padrao) # Saída: 6\n\npizza_especial = Pizza.quatro_queijos()\nprint(pizza_especial.sabor) # Saída: Quatro Queijos</code></pre>\n  </li>\n  <li><strong>Métodos Estáticos (<code>@staticmethod</code>):</strong> Não estão vinculados nem à instância nem à classe. Eles não recebem <code>self</code> ou <code>cls</code> automaticamente. São como funções normais que residem dentro do namespace da classe, geralmente porque têm alguma relação lógica com a classe, mas não dependem do estado da classe ou da instância.\n    <pre><code class=\"languagepython\">class UtilitariosMatematicos:\n    @staticmethod\n    def somar(a, b):\n        return a  b\n\n    @staticmethod\n    def eh_par(numero):\n        return numero % 2 == 0\n\nprint(UtilitariosMatematicos.somar(5, 3)) # Saída: 8\nprint(UtilitariosMatematicos.eh_par(4))   # Saída: True</code></pre>\n  </li>\n</ol>\n\n<h3>Métodos Especiais (Dunder/Magic Methods)</h3>\n<p>Python possui uma série de métodos com nomes especiais, cercados por dois underscores (ex: <code>__init__</code>, <code>__str__</code>). Eles são chamados de \"dunder methods\" (double underscore) ou \"magic methods\". Eles permitem que seus objetos interajam com funcionalidades embutidas do Python, como operadores, a função <code>print()</code>, etc.</p>\n\n<p>Um método especial muito útil é o <strong><code>__str__(self)</code></strong>. Ele define a representação em string \"informal\" ou \"amigável\" de um objeto. É o que é chamado quando você usa <code>print(objeto)</code> ou <code>str(objeto)</code>.</p>\n\n<pre><code class=\"languagepython\">class Ponto:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __str__(self):\n        return f\"Ponto({self.x}, {self.y})\"\n\np1 = Ponto(3, 4)\nprint(p1)  # Saída: Ponto(3, 4) (graças ao __str__)\n\nrepresentacao_string = str(p1)\nprint(representacao_string) # Saída: Ponto(3, 4)</code></pre>\n<p>Sem um método <code>__str__</code> customizado, <code>print(p1)</code> exibiria algo como <code>&lt;__main__.Ponto object at 0x...&gt;</code>.</p>",
        "examples": [
            {
                "title": "Polimorfismo com Formas",
                "code": "class Retangulo:\n    def __init__(self, largura, altura):\n        self.largura = largura\n        self.altura = altura\n    def calcular_area(self):\n        return self.largura * self.altura\n\nclass Triangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n    def calcular_area(self):\n        return (self.base * self.altura) / 2\n\ndef imprimir_area(forma):\n    # Não importa se é Retangulo ou Triangulo, desde que tenha calcular_area()\n    print(f\"A área é: {forma.calcular_area()}\")\n\nret = Retangulo(5, 10)\ntri = Triangulo(4, 5)\n\nimprimir_area(ret)\nimprimir_area(tri)",
                "explanation": "<p>Demonstra o polimorfismo (Duck Typing). A função <code>imprimir_area</code> funciona com objetos de classes diferentes (<code>Retangulo</code> e <code>Triangulo</code>) porque ambos implementam o método <code>calcular_area()</code>. A função não verifica o tipo do objeto, apenas se ele possui o comportamento esperado.</p>"
            },
            {
                "title": "Classe com __str__ e @classmethod",
                "code": "class Produto:\n    imposto_padrao = 0.10 # Atributo de classe\n\n    def __init__(self, nome, preco_base):\n        self.nome = nome\n        self.preco_base = preco_base\n\n    def calcular_preco_final(self):\n        return self.preco_base * (1  self.imposto_padrao)\n\n    def __str__(self):\n        return f\"{self.nome}  Preço Base: R${self.preco_base:.2f}, Preço Final: R${self.calcular_preco_final():.2f}\"\n\n    @classmethod\n    def criar_produto_promocional(cls, nome, preco_original, desconto_percentual):\n        preco_com_desconto = preco_original * (1  desconto_percentual / 100)\n        return cls(nome, preco_com_desconto) # Chama o construtor da classe\n\n# Usando a classe\ncaneta = Produto(\"Caneta Azul\", 2.00)\nprint(caneta) # Usa __str__\n\ncaderno_promo = Produto.criar_produto_promocional(\"Caderno Capa Dura\", 20.00, 15) # 15% de desconto\nprint(caderno_promo)",
                "explanation": "<p>A classe <code>Produto</code> implementa o método especial <code>__str__</code> para uma representação em string amigável. Também possui um método de classe <code>criar_produto_promocional</code> que atua como um construtor alternativo (método fábrica) para criar instâncias de <code>Produto</code> com um cálculo de preço promocional.</p>"
            }
        ],
        "summary": "<p>Polimorfismo em Python, especialmente via Duck Typing, permite escrever código flexível que opera em objetos com base em seus comportamentos, não em seus tipos. Classes abstratas definem interfaces para subclasses. Métodos de classe e estáticos oferecem formas de associar comportamento à classe em si, e métodos especiais como <code>__str__</code> permitem customizar como objetos interagem com funcionalidades do Python.</p>",
        "estimated_time_minutes": 45
    },
    {
        "id": "modulos-python-basico",
        "course_id": "python-intermediario",
        "title": "Módulos e Pacotes (Parte 1): Criando e Usando Módulos",
        "order": 24,
        "description": "Aprenda a criar seus próprios módulos Python para organizar código, e como importar e usar funcionalidades de módulos existentes, incluindo da biblioteca padrão.",
        "learning_objectives": [
            "Entender o que é um módulo em Python e sua finalidade.",
            "Criar um módulo Python simples (um arquivo `.py`).",
            "Importar um módulo inteiro usando `import nome_modulo`.",
            "Importar nomes específicos de um módulo usando `from nome_modulo import nome1, nome2`.",
            "Usar apelidos (aliases) para módulos importados com `import nome_modulo as apelido`.",
            "Compreender o conceito de namespace e como módulos ajudam a evitálo.",
            "Conhecer e utilizar alguns módulos básicos da biblioteca padrão do Python (ex: `math`, `random`)."
        ],
        "key_concepts": [
            "Módulo",
            "Organização de Código",
            "Reutilização",
            "Namespace",
            "Instrução `import`",
            "Instrução `from ... import ...`",
            "Apelido (Alias) de Módulo (`as`)",
            "Biblioteca Padrão do Python",
            "Módulo `math`",
            "Módulo `random`"
        ],
        "content": "<h2>Módulos: Organizando seu Código</h2>\n\n<p>À medida que seus programas Python crescem em tamanho e complexidade, tornase essencial organizar seu código de forma lógica. Uma das principais maneiras de fazer isso em Python é através de <strong>módulos</strong>.</p>\n\n<h3>O que é um Módulo?</h3>\n<p>Um módulo em Python é simplesmente um arquivo contendo definições e instruções Python. O nome do arquivo é o nome do módulo com a extensão <code>.py</code> adicionada. Por exemplo, um arquivo chamado <code>meu_modulo.py</code> é um módulo chamado <code>meu_modulo</code>.</p>\n<p>Módulos permitem que você:</p>\n<ul>\n  <li><strong>Divida seu código</strong> em partes menores e mais gerenciáveis.</li>\n  <li><strong>Reutilize código</strong> em diferentes programas sem precisar copiar e colar.</li>\n  <li><strong>Crie namespaces</strong>, o que ajuda a evitar conflitos de nomes entre diferentes partes do seu código ou com bibliotecas de terceiros.</li>\n</ul>\n\n<h3>Criando um Módulo Simples</h3>\n<p>Vamos criar um módulo chamado <code>utilitarios.py</code> com algumas funções:</p>\n<pre><code class=\"languagepython\"># Arquivo: utilitarios.py\n\nPI = 3.14159\n\ndef somar(a, b):\n    \"\"\"Retorna a soma de dois números.\"\"\"\n    return a  b\n\ndef subtrair(a, b):\n    \"\"\"Retorna a subtração de dois números.\"\"\"\n    return a  b\n\nprint(\"Módulo utilitarios carregado!\") # Esta linha executa quando o módulo é importado pela primeira vez</code></pre>\n\n<h3>Importando Módulos</h3>\n<p>Para usar as definições (funções, variáveis, classes) de um módulo em outro arquivo Python (ou no interpretador interativo), você precisa importálo. Existem algumas maneiras de fazer isso:</p>\n\n<h4>1. Importar o Módulo Inteiro (`import nome_modulo`)</h4>\n<p>Esta é a forma mais comum. Ela importa o módulo, e você acessa suas definições usando o nome do módulo como prefixo (notação de ponto).</p>\n<pre><code class=\"languagepython\"># Arquivo: principal.py (no mesmo diretório que utilitarios.py)\n\nimport utilitarios\n\nresultado_soma = utilitarios.somar(10, 5)\nprint(f\"Soma: {resultado_soma}\")  # Saída: Soma: 15\n\nprint(f\"Valor de PI: {utilitarios.PI}\") # Saída: Valor de PI: 3.14159\n\n# A linha 'Módulo utilitarios carregado!' será impressa uma vez aqui.</code></pre>\n\n<h4>2. Importar Nomes Específicos (`from nome_modulo import nome1, nome2, ...`)</h4>\n<p>Você pode importar nomes específicos (funções, variáveis, classes) diretamente para o namespace do seu script atual. Isso permite usálos sem o prefixo do módulo.</p>\n<pre><code class=\"languagepython\"># Arquivo: principal_from.py\n\nfrom utilitarios import somar, PI\n# from utilitarios import *  # Importa todos os nomes (geralmente não recomendado)\n\nresultado_soma_direta = somar(20, 7) # Não precisa de 'utilitarios.'\nprint(f\"Soma direta: {resultado_soma_direta}\") # Saída: Soma direta: 27\n\nprint(f\"Valor de PI direto: {PI}\") # Saída: Valor de PI direto: 3.14159</code></pre>\n<p><strong>Cuidado:</strong> Usar <code>from nome_modulo import *</code> importa todos os nomes do módulo para o namespace atual. Isso pode levar a conflitos de nomes se o módulo tiver nomes iguais aos que você já definiu, e torna mais difícil rastrear de onde um nome veio. É geralmente desencorajado, exceto em casos específicos (como alguns módulos projetados para isso).</p>\n\n<h4>3. Usando Apelidos (Aliases) (`as`)</h4>\n<p>Você pode dar um apelido a um módulo importado (ou a um nome importado) usando a palavrachave <code>as</code>. Isso é útil para módulos com nomes longos ou para evitar conflitos de nomes.</p>\n<pre><code class=\"languagepython\"># Arquivo: principal_alias.py\n\nimport utilitarios as utils # 'utils' é o apelido para 'utilitarios'\nfrom utilitarios import subtrair as sub # 'sub' é o apelido para 'subtrair'\n\nresultado_sub = utils.subtrair(100, 40)\nprint(f\"Subtração com alias de módulo: {resultado_sub}\") # Saída: 60\n\nresultado_sub_func = sub(50, 5)\nprint(f\"Subtração com alias de função: {resultado_sub_func}\") # Saída: 45</code></pre>\n\n<h3>Namespaces e Módulos</h3>\n<p>Cada módulo tem seu próprio namespace privado. Quando você importa um módulo com <code>import nome_modulo</code>, você está criando uma referência a esse namespace. Isso significa que <code>utilitarios.somar</code> e uma possível função <code>somar</code> definida no seu script <code>principal.py</code> são distintas e não entram em conflito.</p>\n\n<h3>A Biblioteca Padrão do Python</h3>\n<p>Python vem com uma vasta <strong>biblioteca padrão</strong>, que é uma coleção de módulos que fornecem funcionalidades para uma ampla gama de tarefas. Você não precisa instalar nada extra para usálos; basta importálos.</p>\n\n<h4>Módulo `math`</h4>\n<p>Fornece acesso a funções matemáticas.</p>\n<pre><code class=\"languagepython\">import math\n\nprint(math.pi)       # Saída: 3.141592653589793\nprint(math.sqrt(16)) # Saída: 4.0 (raiz quadrada)\nprint(math.pow(2, 3))  # Saída: 8.0 (2 elevado a 3)\nprint(math.sin(math.radians(90))) # Seno de 90 graus (aprox. 1.0)</code></pre>\n\n<h4>Módulo `random`</h4>\n<p>Usado para gerar números pseudoaleatórios.</p>\n<pre><code class=\"languagepython\">import random\n\n# Número aleatório de ponto flutuante entre 0.0 e 1.0 (exclusive)\nprint(random.random())\n\n# Inteiro aleatório entre 1 e 10 (inclusive)\nprint(random.randint(1, 10))\n\n# Escolhe um elemento aleatório de uma sequência\nminha_lista = ['cara', 'coroa']\nprint(random.choice(minha_lista))</code></pre>\n\n<p>Explorar e utilizar módulos é uma parte essencial do desenvolvimento em Python, permitindo que você construa aplicações mais complexas e robustas de forma organizada.</p>",
        "examples": [
            {
                "title": "Usando o Módulo `math`",
                "code": "import math\n\nraio = 5\narea_circulo = math.pi * (raio ** 2)\nprint(f\"A área de um círculo com raio {raio} é {area_circulo:.2f}\")\n\nprint(f\"O fatorial de 5 é: {math.factorial(5)}\")",
                "explanation": "<p>Demonstra a importação do módulo <code>math</code> e o uso de sua constante <code>pi</code> e da função <code>factorial()</code> para realizar cálculos matemáticos.</p>"
            },
            {
                "title": "Criando e Usando um Módulo Próprio",
                "code": "# Suponha que este código está em um arquivo 'meu_calculador.py':\n# def adicionar(x, y):\n#     return x  y\n# \n# def multiplicar(x, y):\n#     return x * y\n\n# Em outro arquivo (ex: 'script_principal.py'):\n# import meu_calculador\n# \n# resultado1 = meu_calculador.adicionar(10, 20)\n# resultado2 = meu_calculador.multiplicar(5, 4)\n# print(f\"Adição: {resultado1}, Multiplicação: {resultado2}\")\n\nprint(\"Simulação: Suponha que importamos 'meu_calculador.py'.\")\nprint(\"Adição: 30, Multiplicação: 20\")",
                "explanation": "<p>Ilustra como você criaria um módulo simples (<code>meu_calculador.py</code>) com funções e como o importaria em outro script para usar essas funções. Como não podemos criar arquivos aqui, o código de exemplo é simulado.</p>"
            }
        ],
        "summary": "<p>Módulos são arquivos Python <code>.py</code> que contêm definições e instruções, permitindo organizar e reutilizar código. Você pode importar módulos inteiros, nomes específicos ou usar apelidos. A biblioteca padrão do Python oferece uma vasta gama de módulos úteis, como <code>math</code> e <code>random</code>.</p>",
        "estimated_time_minutes": 35
    },
    {
        "id": "modulos-pacotes-python",
        "course_id": "python-intermediario",
        "title": "Módulos e Pacotes (Parte 2): Criação e Gerenciamento",
        "order": 25,
        "description": "Aprenda a criar seus próprios pacotes Python, organizar projetos maiores, e gerenciar dependências com pip e ambientes virtuais.",
        "learning_objectives": [
            "Criar um pacote Python (diretório com `__init__.py`).",
            "Organizar múltiplos módulos em um pacote.",
            "Importar módulos e subpacotes de dentro de um pacote.",
            "Entender a função do arquivo `__init__.py`.",
            "Utilizar `pip` para instalar, desinstalar e listar pacotes.",
            "Criar e ativar ambientes virtuais com `venv`.",
            "Compreender a importância do isolamento de projetos com ambientes virtuais."
        ],
        "key_concepts": [
            "Pacote Python",
            "Subpacote",
            "Arquivo `__init__.py`",
            "Importação de Pacotes",
            "Gerenciamento de Pacotes",
            "`pip`",
            "Ambientes Virtuais",
            "`venv`",
            "Isolamento de Projeto",
            "requirements.txt"
        ],
        "content": "<h2>Módulos e Pacotes: Organizando Projetos Maiores</h2>\n\n<p>Vimos como módulos ajudam a organizar código em arquivos separados. Para projetos maiores, que contêm muitos módulos, usamos <strong>pacotes</strong>.</p>\n\n<h3>O que é um Pacote?</h3>\n<p>Um pacote em Python é um diretório que contém múltiplos módulos e, opcionalmente, outros subpacotes. Para que um diretório seja considerado um pacote Python, ele deve conter um arquivo especial chamado <code>__init__.py</code> (que pode estar vazio).</p>\n\n<p>A estrutura de um projeto com pacotes pode ser assim:</p>\n<pre><code>meu_projeto/\n├── main.py\n└── meu_pacote/\n    ├── __init__.py\n    ├── modulo1.py\n    └── sub_pacote/\n        ├── __init__.py\n        └── modulo2.py</code></pre>\n\n<h3>Criando um Pacote</h3>\n<p>Para criar um pacote, basta criar um diretório e adicionar um arquivo <code>__init__.py</code> dentro dele. Você pode então adicionar seus módulos (arquivos <code>.py</code>) a esse diretório.</p>\n\n<h3>Importando de Pacotes</h3>\n<p>Você importa módulos ou nomes de dentro de um pacote usando a notação de ponto:</p>\n\n<pre><code class=\"language-python\"># Arquivo: main.py\n\n# Importando um módulo do pacote\nimport meu_pacote.modulo1\n\n# Importando um nome específico de um módulo do pacote\nfrom meu_pacote.modulo1 import minha_funcao\n\n# Importando um módulo de um subpacote\nimport meu_pacote.sub_pacote.modulo2\n\n# Importando um nome específico de um módulo de um subpacote\nfrom meu_pacote.sub_pacote.modulo2 import MinhaClasse\n\n# Usando o que foi importado\nmeu_pacote.modulo1.outra_funcao()\nminha_funcao()\nobj = meu_pacote.sub_pacote.modulo2.MinhaClasse()\nobj2 = MinhaClasse()</code></pre>\n\n<p>O arquivo <code>__init__.py</code> é executado quando o pacote (ou um módulo/subpacote dentro dele) é importado pela primeira vez. Ele pode ser usado para inicializar o pacote, definir quais nomes serão exportados quando se usa <code>from pacote import *</code>, ou simplesmente estar vazio.</p>\n\n<h3>Gerenciamento de Pacotes com `pip`</h3>\n<p>Python tem um gerenciador de pacotes chamado <strong>pip</strong>. Ele é a ferramenta padrão para instalar, desinstalar e gerenciar bibliotecas e pacotes de terceiros (que não fazem parte da biblioteca padrão).</p>\n\n<ul>\n  <li><strong>Instalar um pacote:</strong> <code>pip install nome_do_pacote</code> (ex: <code>pip install requests</code>)</li>\n  <li><strong>Desinstalar um pacote:</strong> <code>pip uninstall nome_do_pacote</code></li>\n  <li><strong>Listar pacotes instalados:</strong> <code>pip list</code></li>\n  <li><strong>Salvar dependências em um arquivo:</strong> <code>pip freeze > requirements.txt</code></li>\n  <li><strong>Instalar dependências de um arquivo:</strong> <code>pip install -r requirements.txt</code></li>\n</ul>\n\n<h3>Ambientes Virtuais (`venv`)</h3>\n<p>Ao trabalhar em múltiplos projetos Python, é comum que eles dependam de diferentes versões das mesmas bibliotecas. Instalar tudo globalmente pode levar a conflitos.</p>\n\n<p><strong>Ambientes virtuais</strong> resolvem esse problema criando ambientes isolados para cada projeto. Cada ambiente virtual tem sua própria instalação do Python e de pacotes, separada dos outros ambientes e da instalação global do sistema.</p>\n\n<p>Para criar e usar um ambiente virtual com o módulo embutido <code>venv</code>:</p>\n\n<ol>\n  <li><strong>Criar o ambiente:</strong> Abra o terminal na pasta do seu projeto e execute: <code>python -m venv nome_do_ambiente</code> (substitua <code>nome_do_ambiente</code> por um nome, como <code>.venv</code> ou <code>env</code>).</li>\n  <li><strong>Ativar o ambiente:</strong>\n    <ul>\n      <li>No Windows: <code>.\\nome_do_ambiente\\Scripts\\activate</code></li>\n      <li>No macOS/Linux: <code>source nome_do_ambiente/bin/activate</code></li>\n    </ul>\n    Após ativar, o nome do ambiente geralmente aparece no prompt do terminal.</li>\n  <li><strong>Instalar pacotes:</strong> Com o ambiente ativado, use <code>pip install ...</code>. Os pacotes serão instalados APENAS neste ambiente.</li>\n  <li><strong>Desativar o ambiente:</strong> <code>deactivate</code></li>\n</ol>\n\n<p>É uma prática recomendada usar ambientes virtuais para CADA projeto Python.</p>",
        "examples": [
            {
                "title": "Estrutura de Pacote e Importação",
                "code": "# Suponha a seguinte estrutura de arquivos:\n# meu_pacote_exemplo/\n# ├── __init__.py\n# └── saudacoes.py\n# \n# Conteúdo de saudacoes.py:\n# def ola(nome):\n#     return f\"Olá, {nome}!\"\n# \n# Conteúdo de __init__.py (opcionalmente vazio ou com):\n# from . import saudacoes\n# \n# Em outro arquivo (fora do pacote, ex: main.py):\n# import meu_pacote_exemplo.saudacoes\n# from meu_pacote_exemplo.saudacoes import ola\n# \n# print(meu_pacote_exemplo.saudacoes.ola(\"Mundo\"))\n# print(ola(\"Python\"))\n\nprint(\"Simulação de estrutura de pacote e importação.\")\nprint(\"Olá, Mundo!\")\nprint(\"Olá, Python!\")",
                "explanation": "<p>Ilustra como organizar arquivos em um pacote e como importar e usar funções de módulos dentro desse pacote.</p>"
            },
            {
                "title": "Gerenciando pacotes com pip e venv (comandos de terminal)",
                "code": "# Comandos a serem executados no terminal:\n\n# 1. Criar um ambiente virtual (na pasta do projeto)\n# python -m venv .venv\n\n# 2. Ativar o ambiente virtual\n# No Windows: .\\.venv\\Scripts\\activate\n# No macOS/Linux: source .venv/bin/activate\n\n# 3. Instalar um pacote (ex: requests)\n# pip install requests\n\n# 4. Listar pacotes no ambiente\n# pip list\n\n# 5. Salvar dependências\n# pip freeze > requirements.txt\n\n# 6. Desativar o ambiente\n# deactivate\n\nprint(\"Comandos de terminal para gerenciar pacotes e ambientes virtuais.\")",
                "explanation": "<p>Lista os comandos essenciais para criar e gerenciar ambientes virtuais e instalar pacotes usando <code>pip</code> e <code>venv</code>.</p>"
            }
        ],
        "summary": "<p>Pacotes permitem organizar múltiplos módulos em diretórios, facilitando a estruturação de projetos grandes. O arquivo <code>__init__.py</code> marca um diretório como um pacote. <code>pip</code> é a ferramenta padrão para gerenciar pacotes externos, e ambientes virtuais (criados com <code>venv</code>) são essenciais para isolar as dependências de cada projeto, evitando conflitos.</p>",
        "estimated_time_minutes": 40
    },
    {
        "id": "arquivos-pastas-python",
        "course_id": "python-intermediario",
        "title": "Trabalhando com Arquivos e Pastas",
        "order": 26,
        "description": "Explore como ler e escrever em arquivos em diferentes modos, manipular arquivos e diretórios com os módulos os e shutil, e navegar no sistema de arquivos.",
        "learning_objectives": [
            "Abrir e fechar arquivos em modos de texto e binário.",
            "Ler e escrever dados em arquivos.",
            "Utilizar o gerenciador de contexto (`with open(...)`) para garantir o fechamento de arquivos.",
            "Manipular arquivos (copiar, mover, renomear, deletar) com os módulos `os` e `shutil`.",
            "Obter informações sobre arquivos e diretórios.",
            "Navegar e listar conteúdos de diretórios.",
            "Construir caminhos de arquivo de forma segura com `os.path`."
        ],
        "key_concepts": [
            "Manipulação de Arquivos",
            "Leitura de Arquivos",
            "Escrita em Arquivos",
            "Modos de Abertura (`'r'`, `'w'`, `'a'`, `'x'`, `'b'`, `'+'`)",
            "Gerenciador de Contexto (`with`)",
            "Módulo `os`",
            "Módulo `shutil`",
            "Caminhos de Arquivo",
            "`os.path`",
            "Metadados de Arquivo"
        ],
        "content": "<h2>Trabalhando com Arquivos e o Sistema de Arquivos</h2>\n\n<p>Interagir com arquivos e pastas no sistema operacional é uma tarefa comum em programação. Python oferece ferramentas poderosas para isso através de funções embutidas e módulos da biblioteca padrão.</p>\n\n<h3>Lendo e Escrevendo Arquivos</h3>\n<p>A função embutida <code>open()</code> é usada para abrir arquivos. Ela retorna um objeto arquivo que você pode usar para ler ou escrever.</p>\n\n<pre><code class=\"language-python\"># Escrevendo em um arquivo (modo 'w' - write)\n# Se o arquivo existir, seu conteúdo será sobrescrito.\n# Se não existir, será criado.\nwith open('meu_arquivo.txt', 'w') as arquivo:\n    arquivo.write('Esta é a primeira linha.\\n')\n    arquivo.write('Esta é a segunda linha.\\n')\n\n# Lendo de um arquivo (modo 'r' - read)\n# O arquivo deve existir.\nwith open('meu_arquivo.txt', 'r') as arquivo:\n    conteudo = arquivo.read() # Lê todo o conteúdo\n    print(\"Conteúdo do arquivo:\")\n    print(conteudo)\n\n# Lendo linha por linha\nwith open('meu_arquivo.txt', 'r') as arquivo:\n    print(\"Conteúdo linha por linha:\")\n    for linha in arquivo:\n        print(linha, end='') # end='' evita linhas em branco extras</code></pre>\n\n<h4>Modos de Abertura</h4>\n<ul>\n  <li><code>'r'</code>: Leitura (padrão). Erro se o arquivo não existir.</li>\n  <li><code>'w'</code>: Escrita. Cria o arquivo se não existir, sobrescreve se existir.</li>\n  <li><code>'a'</code>: Anexar (append). Cria o arquivo se não existir, adiciona ao final se existir.</li>\n  <li><code>'x'</code>: Criação exclusiva. Cria o arquivo, erro se já existir.</li>\n  <li><code>'b'</code>: Modo binário (para arquivos não textuais como imagens, executáveis). Combinado com outros modos (ex: <code>'rb'</code>, <code>'wb'</code>).</li>\n  <li><code>'+'</code>: Abre para atualização (leitura e escrita). Combinado com outros modos (ex: <code>'r+'</code>, <code>'w+'</code>).</li>\n</ul>\n\n<h4>O Gerenciador de Contexto (`with`)</h4>\n<p>Usar <code>with open(...) as arquivo:</code> é a forma <strong>recomendada</strong> de trabalhar com arquivos. Ele garante que o arquivo seja automaticamente fechado ao sair do bloco <code>with</code>, mesmo que ocorram erros. Sem isso, você precisaria chamar <code>arquivo.close()</code> explicitamente.</p>\n\n<h3>Trabalhando com Arquivos Binários</h3>\n<p>Para ler ou escrever dados que não são texto (como bytes de uma imagem ou dados serializados), use o modo binário ('b').</p>\n\n<pre><code class=\"language-python\"># Escrevendo dados binários\nwith open('dados.bin', 'wb') as f:\n    f.write(b'\\x01\\x02\\x03\\xff') # Bytes literais\n\n# Lendo dados binários\nwith open('dados.bin', 'rb') as f:\n    dados = f.read()\n    print(dados) # Saída: b'\\x01\\x02\\x03\\xff'</code></pre>\n\n<h3>Manipulando Arquivos e Diretórios (`os` e `shutil`)</h3>\n<p>O módulo <code>os</code> fornece funções para interagir com o sistema operacional, incluindo manipulação básica de arquivos e diretórios. O módulo <code>shutil</code> oferece operações de alto nível, como cópia e movimentação.</p>\n\n<pre><code class=\"language-python\">import os\nimport shutil\n\n# Criar um diretório\n# os.makedirs('nova_pasta', exist_ok=True) # Cria a pasta e subpastas se necessário\n# print(\"Diretório 'nova_pasta' criado.\")\n\n# Renomear um arquivo/diretório\n# os.rename('meu_arquivo.txt', 'arquivo_renomeado.txt')\n# print(\"Arquivo renomeado.\")\n\n# Copiar um arquivo\n# shutil.copy('arquivo_renomeado.txt', 'copia_arquivo.txt')\n# print(\"Arquivo copiado.\")\n\n# Mover um arquivo (ou renomear entre diretórios)\n# shutil.move('copia_arquivo.txt', 'nova_pasta/copia_movida.txt')\n# print(\"Arquivo movido.\")\n\n# Listar conteúdo de um diretório\n# print(\"Conteúdo do diretório atual:\")\n# print(os.listdir('.')) # '.' representa o diretório atual\n\n# Verificar se é arquivo ou diretório\n# print(f\"'main.py' é arquivo? {os.path.isfile('main.py')}\")\n# print(f\"'nova_pasta' é diretório? {os.path.isdir('nova_pasta')}\")\n\n# Deletar um arquivo\n# os.remove('arquivo_renomeado.txt')\n# print(\"Arquivo original deletado.\")\n\n# Deletar um diretório (deve estar vazio)\n# os.rmdir('pasta_vazia')\n\n# Deletar um diretório e todo o seu conteúdo\n# shutil.rmtree('nova_pasta')\n# print(\"Diretório e conteúdo deletados.\")\n\nprint(\"Comandos de manipulação de arquivos e diretórios (simulados).\")</code></pre>\n<p><strong>Nota:</strong> Os exemplos acima estão comentados porque a execução direta no ambiente pode não ter permissão ou pode alterar seu sistema de arquivos. Descomente e execute em seu ambiente local para testar.</p>\n\n<h3>Navegando no Sistema de Arquivos (`os.path`)</h3>\n<p>O submódulo <code>os.path</code> fornece funções úteis para trabalhar com caminhos de arquivo de forma independente do sistema operacional.</p>\n\n<pre><code class=\"language-python\">import os\n\n# Juntar partes de um caminho (forma segura)\ncaminho_completo = os.path.join('pasta', 'subpasta', 'arquivo.txt')\nprint(f\"Caminho completo: {caminho_completo}\") # Usa '\\' no Windows, '/' no Linux/macOS\n\n# Obter o nome do diretório e o nome base do arquivo\ndiretorio = os.path.dirname(caminho_completo)\nnome_arquivo = os.path.basename(caminho_completo)\nprint(f\"Diretório: {diretorio}, Arquivo: {nome_arquivo}\")\n\n# Obter o caminho absoluto\ncaminho_absoluto = os.path.abspath('meu_arquivo.txt')\nprint(f\"Caminho absoluto: {caminho_absoluto}\")\n\n# Verificar se um caminho existe\nprint(f\"'meu_arquivo.txt' existe? {os.path.exists('meu_arquivo.txt')}\")</code></pre>\n\n<p>Usar <code>os.path.join()</code> é crucial para garantir que seus caminhos funcionem corretamente em diferentes sistemas operacionais.</p>",
        "examples": [
            {
                "title": "Lendo e processando cada linha de um arquivo",
                "code": "## Suponha um arquivo 'dados.txt' com:\n## Linha 1\n## Linha 2\n## Linha 3\n\n# with open('dados.txt', 'r') as f:\n#     for num_linha, linha in enumerate(f, 1):\n#         print(f\"Linha {num_linha}: {linha.strip()}\") # strip() remove espaços/quebras de linha\n\nprint(\"Simulação de leitura linha a linha com numeração.\")\nprint(\"Linha 1: Linha 1\")\nprint(\"Linha 2: Linha 2\")\nprint(\"Linha 3: Linha 3\")",
                "explanation": "<p>Demonstra como ler um arquivo linha por linha usando um loop <code>for</code> e a função <code>enumerate()</code> para obter o número da linha.</p>"
            },
            {
                "title": "Copiando todos os arquivos .txt de uma pasta para outra",
                "code": "# import os\n# import shutil\n\n# pasta_origem = 'origem'\n# pasta_destino = 'destino'\n\n# os.makedirs(pasta_origem, exist_ok=True)\n# os.makedirs(pasta_destino, exist_ok=True)\n\n# # Criar alguns arquivos de exemplo\n# with open(os.path.join(pasta_origem, 'arquivo1.txt'), 'w') as f: f.write('teste')\n# with open(os.path.join(pasta_origem, 'imagem.jpg'), 'w') as f: f.write('bytes')\n# with open(os.path.join(pasta_origem, 'arquivo2.txt'), 'w') as f: f.write('outro teste')\n\n# for nome_arquivo in os.listdir(pasta_origem):\n#     caminho_origem = os.path.join(pasta_origem, nome_arquivo)\n#     caminho_destino = os.path.join(pasta_destino, nome_arquivo)\n#     if os.path.isfile(caminho_origem) and nome_arquivo.endswith('.txt'):\n#         shutil.copy(caminho_origem, caminho_destino)\n#         print(f\"Copiado: {nome_arquivo}\")\n\n# # Limpeza (opcional)\n# # shutil.rmtree(pasta_origem)\n# # shutil.rmtree(pasta_destino)\n\nprint(\"Simulação de cópia seletiva de arquivos.\")\nprint(\"Copiado: arquivo1.txt\")\nprint(\"Copiado: arquivo2.txt\")",
                "explanation": "<p>Mostra como listar arquivos em um diretório, verificar suas propriedades e copiálos seletivamente para outro diretório usando <code>os</code> e <code>shutil</code>.</p>"
            }
        ],
        "summary": "<p>Python oferece flexibilidade para trabalhar com arquivos (texto e binário) usando a função <code>open()</code> e o gerenciador de contexto <code>with</code>. Os módulos <code>os</code> e <code>shutil</code> fornecem ferramentas para manipular arquivos e diretórios, enquanto <code>os.path</code> ajuda a construir e gerenciar caminhos de forma segura. Essas habilidades são fundamentais para qualquer tarefa que envolva persistência de dados ou interação com o sistema de arquivos.</p>",
        "estimated_time_minutes": 45
    },
    {
        "id": "formatos-arquivos-csv-json",
        "course_id": "python-intermediario",
        "title": "Trabalhando com Formatos de Arquivos: CSV e JSON",
        "order": 27,
        "description": "Aprenda a ler e escrever dados nos formatos CSV e JSON usando os módulos embutidos csv e json, formatos comuns para troca de dados.",
        "learning_objectives": [
            "Entender a estrutura dos formatos CSV e JSON.",
            "Ler dados de arquivos CSV usando o módulo `csv`.",
            "Escrever dados em arquivos CSV usando o módulo `csv`.",
            "Ler dados de arquivos JSON usando o módulo `json`.",
            "Escrever dados em arquivos JSON usando o módulo `json`.",
            "Converter entre objetos Python (listas, dicionários) e strings/arquivos JSON."
        ],
        "key_concepts": [
            "Formato de Arquivo",
            "CSV (Comma Separated Values)",
            "JSON (JavaScript Object Notation)",
            "Módulo `csv`",
            "`csv.reader`",
            "`csv.writer`",
            "Módulo `json`",
            "`json.load()`",
            "`json.dump()`",
            "`json.loads()`",
            "`json.dumps()`",
            "Serialização/Deserialização"
        ],
        "content": "<h2>Trabalhando com Formatos Comuns de Arquivos: CSV e JSON</h2>\n\n<p>CSV e JSON são formatos amplamente utilizados para armazenar e trocar dados. Python possui módulos embutidos que facilitam muito o trabalho com eles.</p>\n\n<h3>CSV (Comma Separated Values)</h3>\n<p>Arquivos CSV são arquivos de texto simples onde cada linha representa um registro de dados, e os campos dentro de cada registro são separados por um delimitador (geralmente uma vírgula, mas pode ser ponto e vírgula, tabulação, etc.).</p>\n\n<h4>Lendo Arquivos CSV</h4>\n<p>Use o módulo <code>csv</code> e a função <code>csv.reader</code> para ler arquivos CSV.</p>\n\n<pre><code class=\"language-python\">import csv\n\n# Suponha um arquivo 'pessoas.csv' com:\n# nome,idade,cidade\n# Ana,30,São Paulo\n# Bruno,25,Rio de Janeiro\n\n# with open('pessoas.csv', mode='r', encoding='utf-8') as arquivo_csv:\n#     leitor_csv = csv.reader(arquivo_csv)\n#     # Pular o cabeçalho, se houver\n#     cabecalho = next(leitor_csv)\n#     print(f\"Cabeçalho: {cabecalho}\")\n#     for linha in leitor_csv:\n#         # Cada 'linha' é uma lista de strings\n#         print(f\"Nome: {linha[0]}, Idade: {linha[1]}, Cidade: {linha[2]}\")\n\nprint(\"Simulação de leitura de arquivo CSV.\")\nprint(\"Cabeçalho: ['nome', 'idade', 'cidade']\")\nprint(\"Nome: Ana, Idade: 30, Cidade: São Paulo\")\nprint(\"Nome: Bruno, Idade: 25, Cidade: Rio de Janeiro\")</code></pre>\n\n<h4>Escrevendo Arquivos CSV</h4>\n<p>Use <code>csv.writer</code> para escrever dados em arquivos CSV.</p>\n\n<pre><code class=\"language-python\">import csv\n\n# dados = [\n#     ['produto', 'preco', 'quantidade'],\n#     ['Lápis', 1.50, 100],\n#     ['Caderno', 15.00, 50]\n# ]\n\n# with open('produtos.csv', mode='w', newline='', encoding='utf-8') as arquivo_csv:\n#     escritor_csv = csv.writer(arquivo_csv)\n#     escritor_csv.writerows(dados) # Escreve múltiplas linhas\n\n# print(\"Arquivo 'produtos.csv' criado com sucesso.\")\n\nprint(\"Simulação de escrita em arquivo CSV.\")\nprint(\"Arquivo 'produtos.csv' seria criado com os dados fornecidos.\")</code></pre>\n<p>O argumento <code>newline=''</code> no <code>open()</code> para escrita é importante para evitar linhas em branco extras no arquivo CSV no Windows.</p>\n\n<h3>JSON (JavaScript Object Notation)</h3>\n<p>JSON é um formato leve de intercâmbio de dados, fácil para humanos lerem e escreverem, e fácil para máquinas analisarem e gerarem. É baseado em uma coleção de pares nome/valor (como dicionários Python) e listas ordenadas de valores (como listas Python).</p>\n\n<h4>Lendo Arquivos JSON</h4>\n<p>Use o módulo <code>json</code> e a função <code>json.load()</code> para ler dados JSON de um arquivo.</p>\n\n<pre><code class=\"language-python\">import json\n\n# Suponha um arquivo 'config.json' com:\n# {\n#   \"usuario\": \"admin\",\n#   \"ativo\": true,\n#   \"permissoes\": [\"ler\", \"escrever\"]\n# }\n\n# with open('config.json', 'r', encoding='utf-8') as arquivo_json:\n#     dados_config = json.load(arquivo_json) # Carrega o JSON do arquivo para um objeto Python\n\n# print(\"Dados do arquivo JSON:\")\n# print(dados_config)\n# print(f\"Usuário: {dados_config['usuario']}\")\n# print(f\"Primeira permissão: {dados_config['permissoes'][0]}\")\n\nprint(\"Simulação de leitura de arquivo JSON.\")\nprint(\"Dados do arquivo JSON: {'usuario': 'admin', 'ativo': True, 'permissoes': ['ler', 'escrever']}\")\nprint(\"Usuário: admin\")\nprint(\"Primeira permissão: ler\")</code></pre>\n\n<h4>Escrevendo Arquivos JSON</h4>\n<p>Use <code>json.dump()</code> para escrever um objeto Python (como um dicionário ou lista) em um arquivo como JSON.</p>\n\n<pre><code class=\"language-python\">import json\n\ndados_para_salvar = {\n    'nome': 'Fulano de Tal',\n    'idade': 42,\n    'cursos': ['Python Básico', 'POO em Python'],\n    'ativo': False\n}\n\n# with open('perfil.json', 'w', encoding='utf-8') as arquivo_json:\n#     json.dump(dados_para_salvar, arquivo_json, indent=4) # indent para formatação legível\n\n# print(\"Arquivo 'perfil.json' criado com sucesso.\")\n\nprint(\"Simulação de escrita em arquivo JSON.\")\nprint(\"Arquivo 'perfil.json' seria criado com os dados fornecidos, formatado com indentação.\")</code></pre>\n\n<h4>Convertendo entre String JSON e Objeto Python</h4>\n<p>Às vezes, você tem dados JSON como uma string (por exemplo, recebidos de uma API web). Use <code>json.loads()</code> para converter uma string JSON para um objeto Python, e <code>json.dumps()</code> para converter um objeto Python para uma string JSON.</p>\n\n<pre><code class=\"language-python\">import json\n\njson_string = '{\"nome\": \"Ciclano\", \"idade\": 29}'\n\n# Converter string JSON para objeto Python\nobjeto_python = json.loads(json_string)\nprint(f\"Objeto Python da string: {objeto_python}\")\nprint(f\"Nome: {objeto_python['nome']}\")\n\n# Converter objeto Python para string JSON\noutro_objeto = {'cidade': 'Fortaleza', 'cep': '60000-000'}\njson_string_criada = json.dumps(outro_objeto, indent=2)\nprint(f\"String JSON criada do objeto: {json_string_criada}\")</code></pre>\n<p>Trabalhar com CSV e JSON é fundamental para muitas tarefas de processamento de dados e comunicação entre sistemas.</p>",
        "examples": [
            {
                "title": "Lendo dados de um CSV e salvando como JSON",
                "code": "import csv\nimport json\n\n# Suponha 'produtos.csv' com:\n# id,nome,preco\n# 1,Produto A,10.50\n# 2,Produto B,20.00\n\n# dados_produtos = []\n# with open('produtos.csv', mode='r', encoding='utf-8') as arquivo_csv:\n#     leitor_csv = csv.DictReader(arquivo_csv) # Usa DictReader para ler como dicionários\n#     for linha in leitor_csv:\n#         # Converte preco para float, id para int\n#         linha['preco'] = float(linha['preco'])\n#         linha['id'] = int(linha['id'])\n#         dados_produtos.append(linha)\n\n# with open('produtos.json', mode='w', encoding='utf-8') as arquivo_json:\n#     json.dump(dados_produtos, arquivo_json, indent=4)\n\n# print(\"Dados lidos do CSV e salvos no JSON.\")\n\nprint(\"Simulação: Lendo CSV e salvando como JSON.\")\nprint(\"Arquivo 'produtos.json' seria criado com o seguinte conteúdo (aproximado):\")\nprint(\"[\")\nprint(\"    {\")\nprint(\"        \\\"id\\\": 1,\")\nprint(\"        \\\"nome\\\": \\\"Produto A\\\",\")\nprint(\"        \\\"preco\\\": 10.5\")\nprint(\"    },\")\nprint(\"    {\")\nprint(\"        \\\"id\\\": 2,\")\nprint(\"        \\\"nome\\\": \\\"Produto B\\\",\")\nprint(\"        \\\"preco\\\": 20.0\")\nprint(\"    }\")\nprint(\"]\")",
                "explanation": "<p>Demonstra a leitura de um arquivo CSV usando <code>csv.DictReader</code> (que trata cada linha como um dicionário) e a conversão desses dados para o formato JSON, salvando em um novo arquivo.</p>"
            }
        ],
        "summary": "<p>Os formatos CSV e JSON são essenciais para intercâmbio de dados. Python facilita a leitura e escrita desses formatos com os módulos embutidos <code>csv</code> e <code>json</code>. O módulo <code>csv</code> é ideal para dados tabulares simples, enquanto o módulo <code>json</code> é usado para dados semiestruturados, permitindo fácil conversão entre objetos Python (listas, dicionários) e representações JSON.</p>",
        "estimated_time_minutes": 40
    },
    {
        "id": "expressoes-regulares-python",
        "course_id": "python-intermediario",
        "title": "Expressões Regulares (Regex)",
        "order": 28,
        "description": "Aprenda a usar Expressões Regulares (Regex) em Python para encontrar padrões em texto, validar formatos e manipular strings de forma poderosa com o módulo re.",
        "learning_objectives": [
            "Entender o conceito e a utilidade das Expressões Regulares.",
            "Compreender a sintaxe básica de Regex (caracteres especiais, metacaracteres, quantificadores).",
            "Utilizar as funções do módulo `re` (`search`, `match`, `findall`, `sub`, `split`).",
            "Aplicar Regex para validação de strings (e-mail, telefone, etc.).",
            "Usar grupos e retroreferências em Regex.",
            "Utilizar flags para modificar o comportamento da busca."
        ],
        "key_concepts": [
            "Expressão Regular (Regex)",
            "Padrão",
            "Módulo `re`",
            "`re.search()`",
            "`re.match()`",
            "`re.findall()`",
            "`re.sub()`",
            "`re.split()`",
            "Metacaracteres",
            "Quantificadores",
            "Classes de Caracteres",
            "Grupos",
            "Flags de Regex"
        ],
        "content": "<h2>Expressões Regulares (Regex): Buscando Padrões em Texto</h2>\n\n<p><strong>Expressões Regulares (Regex)</strong> são sequências de caracteres que definem um padrão de busca. Elas são ferramentas extremamente poderosas e flexíveis para encontrar, substituir ou validar padrões em strings de texto. Em Python, usamos o módulo embutido <code>re</code> para trabalhar com Regex.</p>\n\n<h3>Sintaxe Básica de Regex</h3>\n<p>Regex usa uma sintaxe especial para definir padrões:</p>\n\n<ul>\n  <li><strong>Caracteres Literais:</strong> A maioria dos caracteres corresponde a si mesmo (ex: <code>a</code>, <code>1</code>, <code>@</code>).</li>\n  <li><strong>Metacaracteres:</strong> Caracteres com significado especial.\n    <ul>\n      <li><code>.</code> : Qualquer caractere (exceto quebra de linha).</li>\n      <li><code>^</code> : Início da string.</li>\n      <li><code>$</code> : Fim da string.</li>\n      <li><code>*</code> : Zero ou mais ocorrências do item anterior.</li>\n      <li><code>+</code> : Uma ou mais ocorrências do item anterior.</li>\n      <li><code>?</code> : Zero ou uma ocorrência do item anterior (opcional).</li>\n      <li><code>{n}</code> : Exatamente <code>n</code> ocorrências.</li>\n      <li><code>{n,}</code> : <code>n</code> ou mais ocorrências.</li>\n      <li><code>{n,m}</code> : Entre <code>n</code> e <code>m</code> ocorrências.</li>\n      <li><code>[]</code> : Conjunto de caracteres. Corresponde a qualquer um dos caracteres dentro dos colchetes (ex: <code>[aeiou]</code> corresponde a qualquer vogal).</li>\n      <li><code>[^]</code> : Conjunto negado. Corresponde a qualquer caractere EXCETO os dentro dos colchetes (ex: <code>[^0-9]</code> corresponde a qualquer não dígito).</li>\n      <li><code>|</code> : OU lógico. Corresponde ao padrão antes OU depois do <code>|</code> (ex: <code>gato|cachorro</code>).</li>\n      <li><code>()</code> : Grupos. Agrupa partes do padrão e permite capturar o texto correspondente.</li>\n    </ul>\n  </li>\n  <li><strong>Sequências Especiais (atalhos):</strong>\n    <ul>\n      <li><code>\\d</code> : Corresponde a um dígito (0-9). Equivalente a <code>[0-9]</code>.</li>\n      <li><code>\\D</code> : Corresponde a um não dígito. Equivalente a <code>[^0-9]</code>.</li>\n      <li><code>\\w</code> : Corresponde a um caractere de palavra (letras, números, underscore). Equivalente a <code>[a-zA-Z0-9_]</code>.</li>\n      <li><code>\\W</code> : Corresponde a um não caractere de palavra.</li>\n      <li><code>\\s</code> : Corresponde a um espaço em branco (espaço, tab, quebra de linha).</li>\n      <li><code>\\S</code> : Corresponde a um não espaço em branco.</li>\n    </ul>\n  </li>\n  <li><strong>Escape de Caracteres Especiais:</strong> Use uma barra invertida (<code>\\</code>) para tratar metacaracteres como literais (ex: <code>\\.</code> corresponde a um ponto literal).</li>\n</ul>\n\n<h3>O Módulo `re` em Python</h3>\n<p>O módulo <code>re</code> fornece funções para trabalhar com Regex.</p>\n\n<h4><code>re.search(padrao, string)</code></h4>\n<p>Procura pelo <code>padrao</code> em qualquer lugar da <code>string</code>. Retorna um objeto \"match\" se encontrado, caso contrário, retorna <code>None</code>.</p>\n\n<pre><code class=\"language-python\">import re\n\ntexto = \"Meu email é teste@example.com\"\npadrao_email = r'\\w+@\\w+\\.\\w+' # r'' para raw string (ignora escapes)\n\nmatch = re.search(padrao_email, texto)\n\nif match:\n    print(\"Email encontrado:\", match.group(0)) # group(0) retorna a correspondência inteira\nelse:\n    print(\"Email não encontrado.\")</code></pre>\n\n<h4><code>re.match(padrao, string)</code></h4>\n<p>Procura pelo <code>padrao</code> APENAS no início da <code>string</code>. Retorna um objeto \"match\" se encontrado no início, caso contrário, retorna <code>None</code>.</p>\n\n<pre><code class=\"language-python\">import re\n\ntexto1 = \"Início da frase\"\npadrao = r'^Início'\nmatch1 = re.match(padrao, texto1)\nprint(\"Match 1:\", match1.group(0) if match1 else \"Nenhum\") # Saída: Match 1: Início\n\ntexto2 = \"Começa com outra coisa, mas Início está aqui\"\nmatch2 = re.match(padrao, texto2)\nprint(\"Match 2:\", match2.group(0) if match2 else \"Nenhum\") # Saída: Match 2: Nenhum</code></pre>\n\n<h4><code>re.findall(padrao, string)</code></h4>\n<p>Encontra TODAS as ocorrências não sobrepostas do <code>padrao</code> na <code>string</code> e retorna uma lista de strings correspondentes.</p>\n\n<pre><code class=\"language-python\">import re\n\ntexto = \"Existem números 123 e 456 nesta string.\"\npadrao_numeros = r'\\d+'\n\nlista_numeros = re.findall(padrao_numeros, texto)\nprint(\"Números encontrados:\", lista_numeros) # Saída: Números encontrados: ['123', '456']</code></pre>\n\n<h4><code>re.sub(padrao, substituicao, string)</code></h4>\n<p>Substitui todas as ocorrências do <code>padrao</code> na <code>string</code> pela <code>substituicao</code>.</p>\n\n<pre><code class=\"language-python\">import re\n\ntexto = \"Meu telefone é (11) 98765-4321.\"\npadrao_telefone = r'\\(\\d{2}\\) \\d{4,5}-\\d{4}'\n\ntexto_sem_telefone = re.sub(padrao_telefone, '[TELEFONE REMOVIDO]', texto)\nprint(\"Texto modificado:\", texto_sem_telefone)\n# Saída: Texto modificado: Meu telefone é [TELEFONE REMOVIDO].</code></pre>\n\n<h4><code>re.split(padrao, string)</code></h4>\n<p>Divide a <code>string</code> usando as ocorrências do <code>padrao</code> como delimitadores e retorna uma lista de strings resultantes.</p>\n\n<pre><code class=\"language-python\">import re\n\ntexto = \"Uma,frase;com diferentes-separadores\"\npadrao_separadores = r'[,;-]'\n\npartes = re.split(padrao_separadores, texto)\nprint(\"Partes da string:\", partes) # Saída: Partes da string: ['Uma', 'frase', 'com diferentes', 'separadores']</code></pre>\n\n<h4>Compilação de Regex (`re.compile()`)</h4>\n<p>Para padrões que serão usados várias vezes, é mais eficiente compilálos uma vez usando <code>re.compile()</code>. Isso retorna um objeto Regex que tem os mesmos métodos (`search`, `match`, etc.).</p>\n\n<pre><code class=\"language-python\">import re\n\npadrao_compilado = re.compile(r'\\d{3}-\\d{3}')\n\ntexto1 = \"Código: 123-456\"\ntexto2 = \"Outro código: 789-012\"\n\nmatch1 = padrao_compilado.search(texto1)\nmatch2 = padrao_compilado.search(texto2)\n\nprint(\"Código 1:\", match1.group(0) if match1 else \"Nenhum\")\nprint(\"Código 2:\", match2.group(0) if match2 else \"Nenhum\")</code></pre>\n\n<h4>Flags de Regex</h4>\n<p>Flags modificam o comportamento da busca. Podem ser passadas como argumento nas funções ou na compilação.</p>\n<ul>\n  <li><code>re.IGNORECASE</code> (ou <code>re.I</code>): Ignora maiúsculas/minúsculas.</li>\n  <li><code>re.MULTILINE</code> (ou <code>re.M</code>): Faz com que <code>^</code> e <code>$</code> correspondam ao início/fim de cada linha, não apenas da string inteira.</li>\n  <li><code>re.DOTALL</code> (ou <code>re.S</code>): Faz com que <code>.</code> corresponda também a quebras de linha.</li>\n</ul>\n\n<pre><code class=\"language-python\">import re\n\ntexto = \"Olá Mundo!\\nola mundo!\"\npadrao = r'^ola mundo!$'\n\n# Sem flag MULTILINE\nmatch1 = re.search(padrao, texto)\nprint(\"Sem MULTILINE:\", match1)\n\n# Com flag MULTILINE e IGNORECASE\nmatch2 = re.search(padrao, texto, re.MULTILINE | re.IGNORECASE)\nprint(\"Com MULTILINE e IGNORECASE:\", match2.group(0) if match2 else \"Nenhum\")</code></pre>\n\n<p>Regex é uma habilidade valiosa para qualquer desenvolvedor que trabalhe com processamento de texto.</p>",
        "examples": [
            {
                "title": "Validando formato de CEP",
                "code": "import re\n\ndef validar_cep(cep):\n    # Padrão para CEP no formato XXXXX-XXX\n    padrao_cep = r'^\\d{5}-\\d{3}$'\n    if re.match(padrao_cep, cep):\n        return True\n    else:\n        return False\n\nprint(f\"CEP '12345-678' é válido? {validar_cep('12345-678')}\")\nprint(f\"CEP '12345678' é válido? {validar_cep('12345678')}\")\nprint(f\"CEP 'abcde-fgh' é válido? {validar_cep('abcde-fgh')}\")",
                "explanation": "<p>Usa <code>re.match()</code> com um padrão Regex para verificar se uma string corresponde ao formato de CEP brasileiro XXXXX-XXX.</p>"
            },
            {
                "title": "Extraindo todas as hashtags de um texto",
                "code": "import re\n\ntexto = \"Este é um texto com #hashtags como #python e #programacao. #MaisUma\"\npadrao_hashtag = r'#\\w+'\n\nhashtags = re.findall(padrao_hashtag, texto)\nprint(\"Hashtags encontradas:\", hashtags)",
                "explanation": "<p>Utiliza <code>re.findall()</code> com um padrão que busca por '#' seguido de um ou mais caracteres de palavra para extrair todas as hashtags de uma string.</p>"
            }
        ],
        "summary": "<p>Expressões Regulares (Regex) são padrões para busca e manipulação de texto. O módulo <code>re</code> em Python fornece funções essenciais como <code>search()</code>, <code>match()</code>, <code>findall()</code>, <code>sub()</code> e <code>split()</code> para aplicar Regex. Compreender a sintaxe de Regex e as funções do módulo <code>re</code> é crucial para tarefas de processamento de strings, validação e extração de dados.</p>",
        "estimated_time_minutes": 50
    },
    {
        "id": "apis-requisicoes-web-python",
        "course_id": "python-intermediario",
        "title": "Trabalhando com APIs e Requisições Web",
        "order": 29,
        "description": "Aprenda a interagir com APIs web, entender requisições HTTP e usar a biblioteca requests para fazer requisições e processar respostas.",
        "learning_objectives": [
            "Entender o conceito de API e sua importância na comunicação entre sistemas.",
            "Compreender os princípios básicos de APIs REST.",
            "Identificar os principais métodos HTTP (GET, POST, PUT, DELETE).",
            "Entender o significado dos códigos de status HTTP.",
            "Utilizar a biblioteca `requests` para enviar requisições HTTP.",
            "Enviar parâmetros (query strings) e headers em requisições.",
            "Processar a resposta de uma requisição (status code, headers, conteúdo JSON/texto).",
            "Realizar requisições GET e POST com `requests`."
        ],
        "key_concepts": [
            "API (Application Programming Interface)",
            "API REST",
            "Requisição HTTP",
            "Métodos HTTP (`GET`, `POST`, `PUT`, `DELETE`)",
            "Códigos de Status HTTP",
            "Headers HTTP",
            "Biblioteca `requests`",
            "`requests.get()`",
            "`requests.post()`",
            "Objeto Response",
            "`response.status_code`",
            "`response.json()`",
            "`response.text`",
            "Query String",
            "Autenticação em API"
        ],
        "content": "<h2>Trabalhando com APIs e o Mundo Web</h2>\n\n<p>No desenvolvimento moderno, é muito comum que programas precisem se comunicar com outros serviços ou sistemas pela internet. As <strong>APIs (Application Programming Interfaces)</strong> definem como essa comunicação deve acontecer.</p>\n\n<h3>O que é uma API?</h3>\n<p>Uma API é um conjunto de regras e protocolos que permite que diferentes softwares se comuniquem entre si. Pense nela como um \"contrato\" que define como você pode solicitar informações ou funcionalidades de outro serviço.</p>\n\n<h3>APIs REST</h3>\n<p><strong>REST (Representational State Transfer)</strong> é um estilo arquitetural para APIs web. APIs RESTful usam requisições HTTP para acessar e manipular recursos (dados ou funcionalidades) identificados por URLs.</p>\n\n<h3>Requisições HTTP</h3>\n<p>A comunicação web é baseada no protocolo HTTP (Hypertext Transfer Protocol). Uma <strong>requisição HTTP</strong> é como um cliente (seu programa Python, um navegador) pede algo a um servidor. Uma <strong>resposta HTTP</strong> é o que o servidor envia de volta.</p>\n\n<h4>Métodos HTTP Comuns</h4>\n<ul>\n  <li><code>GET</code>: Solicita dados de um recurso. Não deve ter efeitos colaterais no servidor.</li>\n  <li><code>POST</code>: Envia dados para criar um novo recurso ou enviar dados para processamento.</li>\n  <li><code>PUT</code>: Envia dados para atualizar um recurso existente.</li>\n  <li><code>DELETE</code>: Solicita a remoção de um recurso.</li>\n</ul>\n\n<h4>Códigos de Status HTTP</h4>\n<p>A resposta do servidor inclui um código de status HTTP que indica o resultado da requisição:</p>\n<ul>\n  <li><code>2xx</code> (Sucesso): A requisição foi recebida, entendida e aceita (ex: 200 OK, 201 Created).</li>\n  <li><code>3xx</code> (Redirecionamento): É necessária uma ação adicional para completar a requisição.</li>\n  <li><code>4xx</code> (Erro do Cliente): A requisição contém sintaxe incorreta ou não pode ser atendida (ex: 400 Bad Request, 401 Unauthorized, 404 Not Found).</li>\n  <li><code>5xx</code> (Erro do Servidor): O servidor falhou ao atender a uma requisição aparentemente válida (ex: 500 Internal Server Error).</li>\n</ul>\n\n<h3>Usando a Biblioteca `requests`</h3>\n<p>A biblioteca <code>requests</code> é a forma <strong>recomendada</strong> e mais popular de fazer requisições HTTP em Python. Ela não faz parte da biblioteca padrão, então precisa ser instalada (<code>pip install requests</code>).</p>\n\n<h4>Fazendo Requisições GET</h4>\n<p>Para obter dados de uma API, use <code>requests.get()</code>.</p>\n\n<pre><code class=\"language-python\">import requests\n\n# Exemplo de API pública: JSONPlaceholder (dados falsos para testes)\nurl = 'https://jsonplaceholder.typicode.com/posts/1'\n\ntry:\n    response = requests.get(url)\n\n    # Verificar o status code\n    if response.status_code == 200:\n        # Obter o conteúdo da resposta como JSON (converte para dicionário/lista Python)\n        dados = response.json()\n        print(\"Sucesso!\")\n        print(\"Título do post:\", dados['title'])\n        print(\"Corpo do post:\", dados['body'])\n    else:\n        print(f\"Erro na requisição. Status code: {response.status_code}\")\n        print(\"Conteúdo da resposta:\", response.text)\n\nexcept requests.exceptions.RequestException as e:\n    print(f\"Ocorreu um erro ao fazer a requisição: {e}\")</code></pre>\n\n<h4>Enviando Parâmetros (Query String)</h4>\n<p>Para filtrar ou especificar dados em uma requisição GET, use o parâmetro <code>params</code> (um dicionário).</p>\n\n<pre><code class=\"language-python\">import requests\n\nurl = 'https://jsonplaceholder.typicode.com/posts'\n\n# Buscar posts do usuário com ID 1\nparametros = {'userId': 1}\n\ntry:\n    response = requests.get(url, params=parametros)\n\n    if response.status_code == 200:\n        posts_usuario_1 = response.json()\n        print(f\"Encontrados {len(posts_usuario_1)} posts para o usuário 1.\")\n        for post in posts_usuario_1:\n            print(f\"- {post['title'][:50]}...\") # Imprime os primeiros 50 caracteres do título\n    else:\n        print(f\"Erro: {response.status_code}\")\n\nexcept requests.exceptions.RequestException as e:\n    print(f\"Ocorreu um erro: {e}\")</code></pre>\n\n<h4>Fazendo Requisições POST</h4>\n<p>Para enviar dados (ex: criar um novo recurso), use <code>requests.post()</code> e o parâmetro <code>json</code> (para enviar dados no formato JSON) ou <code>data</code> (para dados de formulário).</p>\n\n<pre><code class=\"language-python\">import requests\n\nurl = 'https://jsonplaceholder.typicode.com/posts'\n\nnovo_post = {\n    'title': 'Meu Novo Post',\n    'body': 'Conteúdo do meu post de teste.',\n    'userId': 1\n}\n\ntry:\n    # Envia os dados como JSON no corpo da requisição\n    response = requests.post(url, json=novo_post)\n\n    # APIs RESTful geralmente retornam 201 Created para criação bem-sucedida\n    if response.status_code == 201:\n        post_criado = response.json()\n        print(\"Post criado com sucesso!\")\n        print(\"ID do novo post:\", post_criado['id'])\n        print(\"Dados retornados:\", post_criado)\n    else:\n        print(f\"Erro ao criar post. Status code: {response.status_code}\")\n        print(\"Conteúdo da resposta:\", response.text)\n\nexcept requests.exceptions.RequestException as e:\n    print(f\"Ocorreu um erro: {e}\")</code></pre>\n\n<h4>Headers HTTP</h4>\n<p>Você pode enviar headers personalizados (ex: para autenticação, especificar tipo de conteúdo) usando o parâmetro <code>headers</code> (um dicionário).</p>\n\n<pre><code class=\"language-python\">import requests\n\nurl = 'https://api.example.com/dados'\n\n# Exemplo de header para autenticação com API Key (substitua pela sua chave)\nheaders = {\n    'Authorization': 'Bearer SUA_API_KEY',\n    'Content-Type': 'application/json'\n}\n\ntry:\n    response = requests.get(url, headers=headers)\n\n    if response.status_code == 200:\n        print(\"Dados recebidos com sucesso (com autenticação simulada).\")\n        # print(response.json()) # Processar os dados, se forem JSON\n    else:\n        print(f\"Erro na requisição. Status code: {response.status_code}\")\n\nexcept requests.exceptions.RequestException as e:\n    print(f\"Ocorreu um erro: {e}\")</code></pre>\n\n<p>Trabalhar com APIs é uma habilidade essencial para integrar seus programas Python com serviços web existentes.</p>",
        "examples": [
            {
                "title": "Buscando informações de um CEP em uma API pública",
                "code": "import requests\n\ndef buscar_cep(cep):\n    # API ViaCEP (substitua o CEP pelo desejado)\n    url = f'https://viacep.com.br/ws/{cep}/json/'\n\n    try:\n        response = requests.get(url)\n\n        if response.status_code == 200:\n            dados_cep = response.json()\n            if 'erro' not in dados_cep:\n                print(f\"CEP Encontrado: {dados_cep['cep']}\")\n                print(f\"Logradouro: {dados_cep['logradouro']}\")\n                print(f\"Bairro: {dados_cep['bairro']}\")\n                print(f\"Cidade/UF: {dados_cep['localidade']}/{dados_cep['uf']}\")\n            else:\n                print(f\"CEP {cep} não encontrado.\")\n        else:\n            print(f\"Erro ao buscar CEP. Status code: {response.status_code}\")\n\n    except requests.exceptions.RequestException as e:\n        print(f\"Ocorreu um erro na requisição: {e}\")\n\n# Exemplo de uso (substitua pelo CEP real)\nbuscar_cep('01001000') # CEP da Praça da Sé, SP",
                "explanation": "<p>Demonstra como usar a biblioteca <code>requests</code> para fazer uma requisição <code>GET</code> a uma API pública (ViaCEP) para buscar informações de um CEP e processar a resposta JSON.</p>"
            }
        ],
        "summary": "<p>APIs permitem a comunicação entre sistemas, sendo APIs REST um estilo comum para web. A biblioteca <code>requests</code> simplifica a realização de requisições HTTP (GET, POST, etc.) em Python. É fundamental entender os métodos HTTP, códigos de status e como enviar/receber dados (JSON, parâmetros, headers) para interagir efetivamente com APIs web.</p>",
        "estimated_time_minutes": 50
    },
    {
        "id": "bancos-dados-intro-python",
        "course_id": "python-intermediario",
        "title": "Introdução a Bancos de Dados com Python",
        "order": 30,
        "description": "Explore os conceitos básicos de bancos de dados, a diferença entre relacionais e NoSQL, e aprenda a interagir com SQLite usando a biblioteca embutida sqlite3.",
        "learning_objectives": [
            "Entender o que é um banco de dados e por que usálos.",
            "Diferenciar bancos de dados relacionais e NoSQL.",
            "Compreender o básico de SQL (Structured Query Language).",
            "Conectar a um banco de dados SQLite usando o módulo `sqlite3`.",
            "Criar tabelas em um banco de dados SQLite.",
            "Inserir, selecionar, atualizar e deletar dados usando comandos SQL via Python.",
            "Utilizar cursores para executar comandos e obter resultados."
        ],
        "key_concepts": [
            "Banco de Dados",
            "Banco de Dados Relacional",
            "Banco de Dados NoSQL",
            "SQL (Structured Query Language)",
            "Tabela",
            "Linha (Registro)",
            "Coluna (Campo)",
            "Chave Primária",
            "Chave Estrangeira",
            "Módulo `sqlite3`",
            "Conexão (`Connection`)",
            "Cursor (`Cursor`)",
            "`execute()`",
            "`commit()`",
            "`rollback()`",
            "`fetchone()`",
            "`fetchall()`"
        ],
        "content": "<h2>Introdução a Bancos de Dados com Python</h2>\n\n<p>Para gerenciar grandes volumes de dados de forma estruturada e persistente, utilizamos <strong>bancos de dados</strong>. Eles permitem armazenar, organizar, recuperar e manipular dados de maneira eficiente.</p>\n\n<h3>Bancos de Dados Relacionais vs. NoSQL</h3>\n<ul>\n  <li><strong>Bancos de Dados Relacionais:</strong> Organizam dados em tabelas com linhas e colunas. As tabelas podem se relacionar entre si. Usam <strong>SQL (Structured Query Language)</strong> para gerenciar os dados. Exemplos: PostgreSQL, MySQL, SQLite, Oracle.</li>\n  <li><strong>Bancos de Dados NoSQL (Not only SQL):</strong> Oferecem modelos de dados mais flexíveis (documentos, chave-valor, grafos, etc.). Não usam SQL como linguagem principal. Geralmente escalam horizontalmente melhor para grandes volumes de dados distribuídos. Exemplos: MongoDB, Cassandra, Redis.</li>\n</ul>\n<p>Nesta lição, focaremos nos bancos de dados relacionais e SQL, utilizando o SQLite, que é um banco de dados leve e embutido, ideal para aprendizado e aplicações menores.</p>\n\n<h3>SQL: A Linguagem dos Bancos Relacionais</h3>\n<p>SQL é a linguagem padrão para interagir com bancos de dados relacionais. Alguns comandos básicos:</p>\n<ul>\n  <li><code>CREATE TABLE</code>: Cria uma nova tabela.</li>\n  <li><code>INSERT INTO</code>: Insere novas linhas em uma tabela.</li>\n  <li><code>SELECT</code>: Recupera dados de uma ou mais tabelas.</li>\n  <li><code>UPDATE</code>: Modifica dados existentes em uma tabela.</li>\n  <li><code>DELETE FROM</code>: Remove linhas de uma tabela.</li>\n</ul>\n\n<h3>Trabalhando com SQLite em Python (`sqlite3`)</h3>\n<p>Python vem com o módulo embutido <code>sqlite3</code>, que fornece uma interface para trabalhar com bancos de dados SQLite.</p>\n\n<pre><code class=\"language-python\">import sqlite3\n\n# 1. Conectar ao banco de dados\n# Se o arquivo não existir, ele será criado.\n# ':memory:' cria um banco de dados na memória RAM (não persistente)\nconn = sqlite3.connect('meu_banco.db')\nprint(\"Conectado ao banco de dados SQLite.\")\n\n# 2. Criar um objeto Cursor\n# Cursores são usados para executar comandos SQL.\ncursor = conn.cursor()\n\n# 3. Executar comandos SQL\n# Criar uma tabela\ncursor.execute('''\nCREATE TABLE IF NOT EXISTS usuarios (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    nome TEXT NOT NULL,\n    idade INTEGER\n);\n''')\nprint(\"Tabela 'usuarios' verificada/criada.\")\n\n# Inserir dados\ncursor.execute(\"INSERT INTO usuarios (nome, idade) VALUES (?, ?)\", ('Alice', 30))\ncursor.execute(\"INSERT INTO usuarios (nome, idade) VALUES (?, ?)\", ('Bob', 25))\n\n# Inserir múltiplos dados de uma vez\nusuarios_novos = [('Charlie', 35), ('David', 28)]\ncursor.executemany(\"INSERT INTO usuarios (nome, idade) VALUES (?, ?)\", usuarios_novos)\nprint(\"Dados inseridos.\")\n\n# 4. Salvar (commit) as mudanças\nconn.commit()\nprint(\"Mudanças salvas.\")\n\n# 5. Selecionar dados\ncursor.execute(\"SELECT id, nome, idade FROM usuarios WHERE idade > ?\", (28,))\n\n# Obter resultados\nusuarios_maiores_28 = cursor.fetchall()\nprint(\"Usuários maiores de 28 anos:\")\nfor usuario in usuarios_maiores_28:\n    print(usuario) # Saída: (id, 'nome', idade)\n\n# Selecionar um único resultado\ncursor.execute(\"SELECT nome FROM usuarios WHERE id = ?\", (1,))\nusuario_id_1 = cursor.fetchone()\nprint(f\"Nome do usuário com ID 1: {usuario_id_1[0]}\")\n\n# 6. Atualizar dados\ncursor.execute(\"UPDATE usuarios SET idade = ? WHERE nome = ?\", (31, 'Alice'))\nconn.commit()\nprint(\"Idade de Alice atualizada.\")\n\n# 7. Deletar dados\ncursor.execute(\"DELETE FROM usuarios WHERE nome = ?\", ('Bob',))\nconn.commit()\nprint(\"Usuário Bob deletado.\")\n\n# 8. Fechar a conexão\nconn.close()\nprint(\"Conexão fechada.\")</code></pre>\n<p>Usar <code>?</code> como placeholder nos comandos SQL e passar os valores como uma tupla/lista separada (como em <code>('Alice', 30)</code>) é a forma <strong>segura</strong> de passar dados, prevenindo ataques de SQL Injection.</p>\n\n<h3>Introdução a ORMs (Opcional)</h3>\n<p><strong>ORMs (Object-Relational Mappers)</strong> são ferramentas que permitem interagir com bancos de dados relacionais usando código Python orientado a objetos, em vez de escrever SQL diretamente. Eles \"mapeiam\" tabelas do banco de dados para classes Python e linhas para objetos Python.</p>\n<p>Vantagens:</p>\n<ul>\n  <li>Escrever código em Python puro.</li>\n  <li>Menos código repetitivo (boilerplate).</li>\n  <li>Portabilidade entre diferentes sistemas de banco de dados (em certa medida).</li>\n</ul>\n<p>Exemplos populares em Python: SQLAlchemy, Django ORM (parte do framework Django).</p>\n<p>Embora poderoso, um ORM adiciona outra camada de abstração. Para começar, entender SQL básico e o módulo <code>sqlite3</code> é fundamental.</p>",
        "examples": [
            {
                "title": "Criando e Populando uma Tabela de Produtos",
                "code": "import sqlite3\n\nconn = sqlite3.connect(':memory:') # Banco de dados na memória\ncursor = conn.cursor()\n\ncursor.execute('''\nCREATE TABLE produtos (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    nome TEXT NOT NULL UNIQUE,\n    preco REAL NOT NULL\n);\n''')\n\nprodutos_iniciais = [\n    ('Teclado', 150.00),\n    ('Mouse', 50.00),\n    ('Monitor', 800.00)\n]\n\ncursor.executemany(\"INSERT INTO produtos (nome, preco) VALUES (?, ?)\", produtos_iniciais)\nconn.commit()\n\ncursor.execute(\"SELECT nome, preco FROM produtos ORDER BY preco DESC\")\nprodutos_ordenados = cursor.fetchall()\n\nprint(\"Produtos (ordenados por preço):\")\nfor prod in produtos_ordenados:\n    print(f\"- {prod[0]}: R${prod[1]:.2f}\")\n\nconn.close()",
                "explanation": "<p>Demonstra a criação de uma tabela <code>produtos</code>, inserção de múltiplos registros e seleção dos dados ordenados por preço, tudo usando comandos SQL executados via <code>sqlite3</code> em um banco de dados na memória.</p>"
            }
        ],
        "summary": "<p>Bancos de dados são essenciais para gerenciar dados persistentes. Bancos relacionais usam tabelas e SQL. Python, com o módulo <code>sqlite3</code>, permite interagir facilmente com bancos SQLite para criar tabelas, inserir, selecionar, atualizar e deletar dados usando comandos SQL. ORMs oferecem uma alternativa orientada a objetos para interagir com bancos de dados, mas entender SQL básico é crucial.</p>",
        "estimated_time_minutes": 55
    },
    {
        "id": "testes-python-intro",
        "course_id": "python-intermediario",
        "title": "Introdução a Testes em Python",
        "order": 31,
        "description": "Entenda a importância de testar seu código, os conceitos de testes unitários e aprenda a escrever e executar testes básicos usando o framework pytest.",
        "learning_objectives": [
            "Compreender por que testes de software são importantes.",
            "Definir o que são testes unitários e seus benefícios.",
            "Conhecer frameworks de teste em Python como `unittest` e `pytest`.",
            "Instalar e configurar o `pytest`.",
            "Escrever funções de teste simples com `pytest`.",
            "Utilizar asserções (`assert`) para verificar resultados esperados.",
            "Executar testes a partir da linha de comando.",
            "Organizar testes em arquivos e diretórios."
        ],
        "key_concepts": [
            "Testes de Software",
            "Testes Unitários",
            "Framework de Teste",
            "`unittest`",
            "`pytest`",
            "Função de Teste",
            "Asserção (`assert`)",
            "Execução de Testes",
            "Relatório de Teste",
            "TDD (Test-Driven Development)"
        ],
        "content": "<h2>Testes em Python: Garantindo a Qualidade do Código</h2>\n\n<p>Testar seu código é uma prática fundamental no desenvolvimento de software. <strong>Testes</strong> ajudam a garantir que seu código funciona como esperado, facilitam a detecção de bugs, tornam as refatorações mais seguras e servem como documentação viva do comportamento do código.</p>\n\n<h3>Por que Testar?</h3>\n<ul>\n  <li><strong>Detecção de Bugs:</strong> Encontre problemas cedo no ciclo de desenvolvimento.</li>\n  <li><strong>Confiança na Refatoração:</strong> Mude a estrutura do código com a certeza de que os testes avisarão se algo quebrar.</li>\n  <li><strong>Documentação:</strong> Testes bem escritos mostram como usar seu código.</li>\n  <li><strong>Melhor Design:</strong> Escrever código testável geralmente leva a um design mais modular e desacoplado.</li>\n</ul>\n\n<h3>Testes Unitários</h3>\n<p><strong>Testes unitários</strong> são testes que verificam a menor \"unidade\" de código isoladamente (geralmente uma função ou método). O objetivo é testar cada parte do código de forma independente para garantir que ela se comporta corretamente em diferentes cenários.</p>\n\n<h3>Frameworks de Teste em Python: `unittest` e `pytest`</h3>\n<p>Python possui frameworks que facilitam a escrita e execução de testes:</p>\n<ul>\n  <li><strong><code>unittest</code>:</strong> Faz parte da biblioteca padrão do Python. Baseado na estrutura de testes do Java (JUnit). Usa classes para organizar testes.</li>\n  <li><strong><code>pytest</code>:</strong> Um framework de teste popular e flexível. Conhecido por sua sintaxe simples e legível, fixtures poderosas e plugins ricos. É frequentemente a escolha preferida em projetos Python modernos.</li>\n</ul>\n<p>Vamos focar no <code>pytest</code> por sua simplicidade e popularidade.</p>\n\n<h3>Instalando `pytest`</h3>\n<p>Como <code>pytest</code> não é parte da biblioteca padrão, você precisa instalálo (preferencialmente em um ambiente virtual):</p>\n<pre><code>pip install pytest</code></pre>\n\n<h3>Escrevendo Testes com `pytest`</h3>\n<p>Com <code>pytest</code>, você escreve testes em funções separadas. As funções de teste devem ter nomes que começam com <code>test_</code>.</p>\n\n<p>Suponha que você tenha um arquivo <code>calculadora.py</code>:</p>\n<pre><code class=\"language-python\"># Arquivo: calculadora.py\n\ndef somar(a, b):\n    return a + b\n\ndef subtrair(a, b):\n    return a - b</code></pre>\n\n<p>Você criaria um arquivo de teste (geralmente no mesmo diretório ou em uma pasta <code>tests/</code>) chamado <code>test_calculadora.py</code>:</p>\n\n<pre><code class=\"language-python\"># Arquivo: test_calculadora.py\n\n# Importa a função a ser testada\nfrom calculadora import somar, subtrair\n\n# Função de teste para somar\ndef test_somar():\n    # Usamos 'assert' para verificar se o resultado é o esperado\n    assert somar(2, 3) == 5\n    assert somar(-1, 1) == 0\n    assert somar(0, 0) == 0\n\n# Função de teste para subtrair\ndef test_subtrair():\n    assert subtrair(5, 2) == 3\n    assert subtrair(10, 10) == 0\n    assert subtrair(0, 5) == -5</code></pre>\n\n<h4>Asserções (`assert`)</h4>\n<p>A declaração <code>assert</code> é a forma básica de verificar se uma condição é verdadeira em Python. Em testes, usamos <code>assert</code> para verificar se o resultado de uma operação é igual ao resultado esperado. Se a condição após o <code>assert</code> for falsa, o teste falha e o <code>pytest</code> reporta o erro.</p>\n\n<h3>Executando Testes</h3>\n<p>Abra o terminal na pasta do seu projeto (onde está o arquivo <code>test_calculadora.py</code>) e execute o comando:</p>\n<pre><code>pytest</code></pre>\n<p>O <code>pytest</code> automaticamente descobrirá e executará as funções de teste. Ele exibirá um relatório indicando quantos testes foram executados e se passaram ou falharam.</p>\n\n<pre><code># Exemplo de saída do pytest:\n# ============================= test session starts =============================\n# platform linux -- Python 3.x.x, pytest-x.x.x, pluggy-x.x.x\n# rootdir: /caminho/para/seu/projeto\n# collected 2 items\n# \n# test_calculadora.py ..                                                  [100%]\n# \n# ============================== 2 passed in X.XXs ==============================\n</code></pre>\n\n<h3>Organização de Testes</h3>\n<p>Para projetos maiores, é comum organizar os arquivos de teste em uma pasta separada, geralmente chamada <code>tests/</code>, na raiz do projeto.</p>\n<pre><code>meu_projeto/\n├── calculadora.py\n└── tests/\n    └── test_calculadora.py</code></pre>\n<p>Quando você executa <code>pytest</code> na raiz do projeto, ele encontrará a pasta <code>tests/</code> e executará os testes dentro dela.</p>\n\n<h3>Introdução a TDD (Opcional)</h3>\n<p><strong>TDD (Test-Driven Development)</strong>, ou Desenvolvimento Orientado a Testes, é uma metodologia de desenvolvimento onde você escreve os testes ANTES de escrever o código que será testado. O ciclo TDD é:</p>\n<ol>\n  <li>Escreva um teste para uma pequena funcionalidade que ainda não existe.</li>\n  <li>Execute os testes (o novo teste deve falhar).</li>\n  <li>Escreva o código mínimo necessário para fazer o novo teste passar.</li>\n  <li>Execute os testes novamente (todos devem passar agora).</li>\n  <li>Refatore o código (melhore-o) sem quebrar os testes.</li>\n  <li>Repita o ciclo.</li>\n</ol>\n<p>TDD incentiva um design mais limpo e garante que o código seja testável desde o início.</p>\n\n<p>Começar a escrever testes unitários é um passo importante para se tornar um desenvolvedor Python mais profissional e confiante.</p>",
        "examples": [
            {
                "title": "Testando casos de borda e exceções com pytest",
                "code": "import pytest\nfrom calculadora import somar # Suponha que somar esteja em calculadora.py\n\ndef test_somar_numeros_grandes():\n    assert somar(1000000, 2000000) == 3000000\n\ndef test_somar_floats():\n    # Cuidado com comparações de ponto flutuante exatas\n    assert somar(0.1, 0.2) == pytest.approx(0.3)\n\n# Exemplo (comentado) de como testar uma exceção esperada\n# def dividir(a, b):\n#     if b == 0:\n#         raise ValueError(\"Divisão por zero não permitida\")\n#     return a / b\n\n# def test_dividir_por_zero():\n#     with pytest.raises(ValueError) as excinfo:\n#         dividir(10, 0)\n#     assert \"Divisão por zero\" in str(excinfo.value)",
                "explanation": "<p>Mostra como escrever testes para casos específicos (números grandes, floats) e como usar <code>pytest.raises</code> para verificar se uma função levanta a exceção esperada em determinadas condições.</p>"
            }
        ],
        "summary": "<p>Testes são cruciais para a qualidade do software. Testes unitários verificam partes isoladas do código. Frameworks como <code>pytest</code> simplificam a escrita e execução de testes usando funções com nomes <code>test_*</code> e asserções (`assert`). Executar <code>pytest</code> no terminal descobre e roda seus testes, fornecendo um relatório. Organizar testes em uma pasta <code>tests/</code> é uma boa prática. TDD é uma metodologia onde testes são escritos antes do código.</p>",
        "estimated_time_minutes": 45
    },
    {
        "id": "projeto-final-curso-intermediario",
        "course_id": "python-intermediario",
        "title": "Projeto Final do Curso de Python Intermediário",
        "order": 32,
        "description": "Este é o momento de aplicar todo o seu conhecimento adquirido no curso de Python Avançado para desenvolver um projeto completo e demonstrar suas habilidades.",
        "learning_objectives": [
            "Consolidar o aprendizado do curso através de um projeto prático.",
            "Aplicar conceitos avançados de Python em um cenário real.",
            "Desenvolver um portfólio com um projeto significativo."
        ],
        "key_concepts": [
            "Desenvolvimento de Projeto",
            "Aplicação Prática",
            "Portfólio",
            "Integração de Conhecimentos"
        ],
        "content": "<h2>Projeto Final do Curso</h2><p>Chegou a hora de colocar em prática tudo o que você aprendeu! O exercício listado nesta página detalha os requisitos para o seu projeto final. Este projeto é uma oportunidade para você integrar os diversos conceitos abordados ao longo do curso, desde Programação Orientada a Objetos avançada, manipulação de dados, desenvolvimento web (se aplicável ao seu projeto escolhido), concorrência, até boas práticas de desenvolvimento e testes.</p><p>Dedique-se a este projeto, pois ele será uma peça fundamental no seu portfólio como desenvolvedor Python e uma excelente forma de solidificar seu aprendizado.</p><p>Consulte as instruções do exercício para começar. Boa sorte e divirta-se codando!</p>",
        "examples": [],
        "summary": "O projeto final é a culminação do seu aprendizado no curso de Python Avançado. Siga as instruções do exercício associado para desenvolver uma aplicação completa e robusta.",
        "estimated_time_minutes": 0
    },
    {
        "id": "tratamento-excecoes",
        "course_id": "python-intermediario",
        "title": "Tratamento de Exceções e Erros",
        "order": 1,
        "description": "Aprenda a lidar com erros e situações inesperadas em seus programas usando blocos try, except, else e finally.",
        "learning_objectives": [
            "Entender o que são exceções e por que ocorrem.",
            "Utilizar a estrutura try-except para capturar erros.",
            "Tratar múltiplos tipos de exceções.",
            "Usar as cláusulas else e finally.",
            "Levantar exceções personalizadas com raise."
        ],
        "key_concepts": [
            "Exceção",
            "Try/Except",
            "Traceback",
            "Raise",
            "Finally"
        ],
        "content": "<h2>O que são Exceções?</h2><p>Exceções são erros detectados durante a execução do programa...</p>",
        "examples": [
            {
                "title": "Tratamento Básico",
                "code": "try:\n    x = 10 / 0\nexcept ZeroDivisionError:\n    print('Não é possível dividir por zero!')",
                "explanation": "Captura o erro de divisão por zero."
            }
        ],
        "estimated_time_minutes": 30
    }
]